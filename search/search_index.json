{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the QFlux Documentation","text":"<p>This is a Python package containing various protocols for performing quantum dynamics simulations with quantum devices. Each submodule contains object-oriented implementations for these protocols as demonstrated in our publication, as well as comprehensive tutorial notebooks designed to help users understand, implement and build upon various simulation techniques for studying quantum dynamics using quantum computer frameworks. Each tutorial is provided in Python, using Jupyter Notebooks to offer detailed explanations in both markdown and code comments.</p>"},{"location":"#installation","title":"Installation","text":"<p>This project uses <code>uv</code> for fast and reliable Python package management. To set up your development environment:</p> <pre><code># Create and activate a virtual environment\nuv venv\nsource .venv/bin/activate\n\n# Install the package and all development dependencies\nuv pip install -e \".[dev]\"\n# Initiate pre-commit checks\npre-commit install\n</code></pre> <p>This will install all necessary dependencies, including development tools like pre-commit hooks, testing frameworks, and documentation generators.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>.\n\u251c\u2500\u2500 data/           # Data files and resources\n\u251c\u2500\u2500 docs/           # Documentation files (MkDocs)\n\u251c\u2500\u2500 scripts/        # Utility and automation scripts\n\u251c\u2500\u2500 src/            # Source code\n\u2502   \u2514\u2500\u2500 qflux/\n\u251c\u2500\u2500 tests/          # Test files\n\u251c\u2500\u2500 .github/        # GitHub Actions workflows\n\u251c\u2500\u2500 mkdocs.yml      # MkDocs configuration\n\u251c\u2500\u2500 pyproject.toml  # Project dependencies and settings\n\u2514\u2500\u2500 .pre-commit-config.yaml  # Pre-commit hooks configuration\n</code></pre>"},{"location":"#development-setup","title":"Development Setup","text":""},{"location":"#documentation","title":"Documentation","text":"<p>This project uses MkDocs with the Material theme for documentation. To work with the documentation locally:</p> <ol> <li>Make sure you have all development dependencies installed</li> <li>Run the documentation server:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>Open your browser and navigate to <code>http://127.0.0.1:8000</code></li> </ol> <p>The documentation will automatically reload when you make changes to the markdown files.</p>"},{"location":"#code-quality-tools","title":"Code Quality Tools","text":"<p>We use pre-commit hooks to ensure code quality and consistency. The following tools are configured in <code>.pre-commit-config.yaml</code>:</p> <ul> <li>Ruff: A fast Python linter and formatter</li> <li>Runs linting checks with auto-fix capability</li> <li>Handles code formatting</li> </ul> <p>After installing the development dependencies (as described in the Installation section), enable the pre-commit hooks by running:</p> <pre><code>pre-commit install\n</code></pre> <p>Now the hooks will run automatically on every commit, ensuring code quality and consistency.</p>"},{"location":"#managing-dependencies","title":"Managing Dependencies","text":"<p>This project uses <code>uv</code> for fast and reliable dependency management. Here's how to manage your dependencies:</p>"},{"location":"#adding-new-dependencies","title":"Adding New Dependencies","text":"<p>To add a new package dependency:</p> <pre><code>uv add package_name\n# Add a development dependency\nuv add --dev package_name\n</code></pre> <p>This will:</p> <ol> <li>Install the package in your virtual environment</li> <li>Update your <code>pyproject.toml</code> with the new dependency</li> <li>Update the <code>uv.lock</code> file with exact versions</li> </ol>"},{"location":"#synchronizing-dependencies","title":"Synchronizing Dependencies","text":"<p>If you pull changes that include new dependencies or switch branches, synchronize your environment:</p> <pre><code>uv sync\n</code></pre> <p>This ensures your virtual environment exactly matches the dependencies specified in the lock file, removing any packages you don't need and installing any that are missing.</p>"},{"location":"#writing-documentation","title":"Writing Documentation","text":"<p>This project follows a structured approach to documentation. Each module should have its own markdown file in the <code>docs/batistatemplate/</code> directory. Documentation files might include:</p> <ol> <li>Overview: A brief description of the module's purpose and key features</li> <li>Concepts: Explanation of important concepts and design decisions</li> <li>Examples: Code examples showing common usage patterns</li> <li>Source Code: Auto-generated documentation from source code annotations</li> </ol>"},{"location":"#source-code-documentation","title":"Source Code Documentation","text":"<p>Each documentation file should end with a Source Code section that imports and displays the module's classes and functions. Use the following structure:</p> <pre><code>## Source Code\n\n::: batistatemplate.module_name\n    handler: python\n    options:\n      show_root_heading: true\n      show_source: true\n      members:\n        - ClassName1\n        - ClassName2\n        - function_name1\n        - function_name2\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For more detailed information about specific components and usage examples, please navigate through the documentation using the navigation menu.</p>"},{"location":"logging/","title":"Logging Best Practices","text":"<p>This guide explains how to effectively use Python's logging module in our codebase, whether you're writing modules, running scripts from CLI, or working in Jupyter notebooks.</p>"},{"location":"logging/#environment-variables","title":"Environment Variables","text":"<p>The application's log level can be controlled using the <code>QFLUX_LOG_LEVEL</code> environment variable:</p> <pre><code># Set log level for the current session\nexport QFLUX_LOG_LEVEL=DEBUG\npython your_script.py\n\n# Or set it for a single command\nQFLUX_LOG_LEVEL=DEBUG python your_script.py\n</code></pre> <p>Valid log levels are:</p> <ul> <li><code>DEBUG</code>: Most verbose, detailed debugging information</li> <li><code>INFO</code>: General operational information (default)</li> <li><code>WARNING</code>: Unexpected situations that aren't errors</li> <li><code>ERROR</code>: Serious problems that need attention</li> <li><code>CRITICAL</code>: Critical issues that may cause program failure</li> </ul>"},{"location":"logging/#module-development","title":"Module Development","text":"<p>When writing a module, follow these guidelines:</p> <pre><code>from batistatemplate.utils.logging_config import logger\n\ndef my_function():\n    # Use appropriate log levels\n    logger.debug(\"Detailed information for debugging\")\n    logger.info(\"General information about progress\")\n    logger.warning(\"Something unexpected but not error\")\n    logger.error(\"A more serious problem\")\n    logger.critical(\"Program may not be able to continue\")\n</code></pre> <p>Key points:</p> <ul> <li>Don't configure the logger in your modules</li> <li>Always use <code>from batistatemplate.utils.logging_config import logger</code></li> <li>Choose appropriate log levels</li> <li>Don't use print statements for debugging</li> <li>Don't add parameters like <code>verbose</code> to your functions</li> </ul>"},{"location":"logging/#jupyter-notebook-usage","title":"Jupyter Notebook Usage","text":"<p>For Jupyter notebooks, put this in your first cell:</p> <pre><code>from batistatemplate.utils.logging_config import logger\n\nlogger.setLevel(logging.DEBUG)  # To see debug messages\nlogger.setLevel(logging.INFO)   # Back to info only\n</code></pre>"},{"location":"logging/#log-levels-guide","title":"Log Levels Guide","text":"<p>Choose the appropriate level based on the message importance:</p> <ul> <li>DEBUG: Detailed information for diagnosing problems</li> </ul> <pre><code>logger.debug(f\"Processing data frame with shape {df.shape}\")\n</code></pre> <ul> <li>INFO: Confirmation that things are working as expected</li> </ul> <pre><code>logger.info(\"Model training started\")\n</code></pre> <ul> <li>WARNING: Indication that something unexpected happened</li> </ul> <pre><code>logger.warning(\"Using fallback parameter value\")\n</code></pre> <ul> <li>ERROR: More serious problem that prevented function from working</li> </ul> <pre><code>logger.error(\"Failed to load model weights\")\n</code></pre> <ul> <li>CRITICAL: Program may not be able to continue</li> </ul> <pre><code>logger.critical(\"Out of memory - cannot continue processing\")\n</code></pre>"},{"location":"logging/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Configuring Loggers in Modules: Only configure logging in your entry points (main scripts, notebooks)</p> </li> <li> <p>Using Print Statements: Avoid print statements for debugging; use logger.debug instead</p> </li> <li> <p>Hard-coding Log Levels: Don't set log levels in your modules; let the application control them</p> </li> <li> <p>Creating Multiple Handlers: Clear existing handlers in notebooks to avoid duplicate logs</p> </li> <li> <p>Using f-strings for Debug Messages: For expensive operations, check level first:</p> </li> </ol> <pre><code># Bad (string formatting happens regardless of level)\nlogger.debug(f\"Expensive operation result: {expensive_operation()}\")\n\n# Good (string formatting only happens if needed)\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(f\"Expensive operation result: {expensive_operation()}\")\n</code></pre>"},{"location":"qflux/closed_systems/","title":"Closed Systems Module","text":""},{"location":"qflux/closed_systems/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>closed_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/closed_systems/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/closed_systems/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/closed_systems/#source-code","title":"Source Code","text":""},{"location":"qflux/closed_systems/#qflux.closed_systems","title":"<code>qflux.closed_systems</code>","text":""},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS","title":"<code>DynamicsCS</code>","text":"<p>Class for closed-system dynamics. All input parameters must be in atomic units to ensure consistency. Please be sure to convert your parameters to atomic units prior to instantiation.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>class DynamicsCS:\n    \"\"\"\n        Class for closed-system dynamics. **All input parameters must be in\n        atomic units to ensure consistency. Please be sure to convert your\n        parameters to atomic units prior to instantiation.**\n\n    \"\"\"\n\n    def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n                 omega: float = 1.0) -&gt; None:\n        \"\"\"\n        Args:\n            n_basis (int): Number of states to include in the chosen representation. If basis\n                = 'ladder', this is the Fock cutoff and defines the number of states\n                used for representing the ladder operators. If basis = 'coordinate',\n                this defines the number of points for the position and momenta.\n\n            xo (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 Bohr.\n\n            po (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 au.\n\n            mass (float, optional): Defines the mass of the particle/system of interest.\n                Default is 1.0 au.\n\n            omega (float, optional): Frequency of harmonic oscillator.\n                Default is 1.0 au.\n\n        \"\"\"\n        #--------- Required Attributes Populated During Execution ----------#\n        self.n_basis                   = n_basis\n        self.xo                        = xo\n        self.po                        = po\n        self.mass                      = mass\n        self.hbar                      = 1.0\n        self.omega                     = omega\n        #--------- Below are Attributes Populated During Execution ---------#\n        self.total_time                = 0.\n        self.n_tsteps                  = 0.\n        self._KE_op                    = None\n        self._PE_op                    = None\n        self.H_op                      = None\n        self.prop_KE_op                = None\n        self.prop_PE_op                = None\n        self.prop_H_op                 = None\n        # Grid operators\n        self._KE_grid                  = None\n        self._PE_grid                  = None\n        self.H_grid                    = None\n        self.PE_prop_grid              = None\n        self.KE_prop_grid              = None\n\n\n    def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid` and `self.dx` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values between\n        `x_min` and `x_max`.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n\n        Returns:\n            self.dx (float): Spacing between points in the x-coordinate grid.\n            self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n        \"\"\"\n        dx = (x_max - x_min) / self.n_basis\n        x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n        self.dx = dx\n        self.x_grid = x_grid\n        return\n\n\n    def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.p_grid` and `self.dp` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n            reorder (bool): Boolean flag to determine whether points should be reordered to be\n                compatible with the FFT routine or not.\n\n        Returns:\n            self.dp (float): Spacing between points in the p-coordinate grid.\n            self.pgrid (array_like): Array of momentum grid points\n        \"\"\"\n        dp = 2 * np.pi / (x_max - x_min)\n        pmin = -dp * self.n_basis / 2\n        pmax = dp * self.n_basis / 2\n        plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n        minus_pgrid = - np.flip(np.copy(plus_pgrid))\n        if reorder:\n            p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n        else:\n            p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n        self.p_grid = p_grid\n        self.dp = dp\n        return\n\n\n    def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n        attributes. This functions generates an array of `self.n_basis`\n        evenly spaced values.\n\n        Args:\n            x_min : float\n                Minimum value of x-coordinates\n            x_max : float\n                Maximum value of x-coordinates\n            reorder_p : bool\n                Boolean flag to determine whether momentum values should be\n                reordered to be compatible with the FFT routine or not.\n\n        Returns:\n            self.dx : float\n                Spacing between points in the x-coordinate grid.\n            self.xgrid : array_like\n                Array of x-values\n            self.dp : float\n                Spacing between points in the p-coordinate grid.\n            self.pgrid : array_like\n                Array of p-values\n        \"\"\"\n        self._get_xgrid(x_min, x_max)\n        self._get_pgrid(x_min, x_max, reorder=reorder_p)\n        return\n\n\n    def initialize_operators(self):\n        \"\"\"\n            Function to initialize core operators in the chosen basis.\n\n        \"\"\"\n\n        self.a_op = qt.destroy(self.n_basis)\n        self.x_op = qt.position(self.n_basis)\n        self.p_op = qt.momentum(self.n_basis)\n        return\n\n\n    def _set_hamiltonian_grid(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n\n            # Set attributes for the coordinate basis\n            self._PE_grid = self.mass * self.omega ** 2 * self.x_grid ** 2 / 0.5\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_grid / x0\n            self._PE_grid = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def _set_hamiltonian_qt(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n            # Set attributes for the ladder basis\n            self.H_op = self.hbar * self.omega * (self.a_op.dag() * self.a_op + 0.5)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self._PE_op = self.mass * self.omega ** 2 * self.x_op ** 2 / 0.5\n            self.H_xp_op = self._PE_op + self._KE_op\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_op / x0\n            self.x0 = x0\n            self._PE_op = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self.H_op = self._PE_op + self._KE_op\n            return\n\n    def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n        \"\"\"\n        Function to define Hamiltonian.\n\n        Args:\n            potential_type : str\n                String defining the type of potential energy surface.\n                Available options are: ('harmonic', 'quartic', ...)\n\n                Note: You can manually define your potential energy using the functions:\n                    - set_H_grid_with_custom_potential\n                    - set_H_op_with_custom_potential\n\n        \"\"\"\n\n        if potential_type == 'harmonic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        elif potential_type == 'quartic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        else:\n            print('Error, this potential type has not yet been implemented!')\n            print('Set your parameters with the custom functions!')\n        return\n\n\n    def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the custom potential\n                energy. Must return an array\n\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_grid = potential\n        self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n        self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the potential\n                energy in terms of qutip QObj operators. Must return a qutip.Qobj\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_op = potential\n        self._KE_op = self.p_op ** 2 / (2. * self.mass)\n        self.H_op = self._PE_op + self._KE_op\n        return\n\n\n    def set_initial_state(self, wfn_omega: float = 1.0):\n        \"\"\"\n        Function to define the initial state. By default, a coherent state is\n        used as the initial state defined in the basis chosen upon instantiation\n\n        Args:\n            wfn_omega (float, optional): Defines the frequency/width of the initial state.\n                Default is 1.0 au.\n        \"\"\"\n\n        alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n        psio = qt.coherent(self.n_basis, alpha=alpha_val)\n        # Now populate the initial state in the grid basis\n        normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n        exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                             ((self.x_grid - self.xo) ** 2)\n                             + 1j * self.po * self.x_grid / self.hbar\n                             )\n\n        coherent_state = normalization * exponential\n        # Set the attributes\n        self.psio_grid = coherent_state\n        self.psio_op = psio\n        return\n\n\n\n    def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized grid state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return an array\n        \"\"\"\n\n        self.psio_grid = function_name(**kwargs)\n        return\n\n    def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized ladder state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return a qutip.Qobj.\n        \"\"\"\n\n        self.psio_op = function_name(**kwargs)\n        return\n\n    def set_propagation_time(self, total_time: float, n_tsteps: int):\n        \"\"\"\n        Function to define the propagation time, an array of times from\n        t=0 to total_time, with n_tsteps equally-spaced steps.\n\n        Args:\n        total_time : float\n            The total time for which we wish to compute the dynamics.\n        n_tsteps : int\n            The number of equally-spaced time steps used to compute the dynamics\n\n        Returns:\n        self.tlist : array-like\n\n        \"\"\"\n\n        self.tlist = np.linspace(0., total_time, n_tsteps)\n        self.dt = self.tlist[1] - self.tlist[0]\n        return\n\n\n    def propagate_qt(self, solver_options : dict = None):\n        \"\"\"\n        Function used to propagate with qutip.\n\n        Args:\n            solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n        Returns:\n            dynamics_results (array-like): array containing the propagated state\n\n        \"\"\"\n\n        options = {'nsteps': len(self.tlist),\n                    'progress_bar': True}\n\n        if solver_options:\n            for key in solver_options:\n                options[key] = solver_options[key]\n\n        results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                             options=options)\n\n        self.dynamics_results_op = results\n        return\n\n\n    def propagate_SOFT(self):\n        \"\"\"\n        Function used to propagate with the 2nd-Order Trotter Expansion.\n\n        $$\n        e^{- \\frac{i}{\\\\hbar} H t} \\approx e^{- \\frac{i}{\\\\hbar} V t/2} e^{- \\frac{i}{\\\\hbar} T t} e^{- \\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n        $$\n\n        Returns:\n            dynamics_results_grid (array-like): array containing the propagated state\n                                                shape (n_tsteps x self.n_basis)\n\n        \"\"\"\n        self.tau = self.tlist[1] - self.tlist[0]\n        PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n        KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n        self.PE_prop_grid = PE_prop\n        self.KE_prop_grid = KE_prop\n\n        propagated_states = [self.psio_grid]\n        psi_t = self.psio_grid\n        for ii in range(len(self.tlist)):\n            psi_t_position_grid = PE_prop * psi_t\n            psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n            psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n            propagated_states.append(psi_t)\n\n        self.dynamics_results_grid = np.asarray(propagated_states)[:-1]\n        return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.__init__","title":"<code>__init__(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>n_basis</code> <code>int</code> <p>Number of states to include in the chosen representation. If basis = 'ladder', this is the Fock cutoff and defines the number of states used for representing the ladder operators. If basis = 'coordinate', this defines the number of points for the position and momenta.</p> <code>128</code> <code>xo</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 Bohr.</p> <code>1.0</code> <code>po</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 au.</p> <code>0.0</code> <code>mass</code> <code>float</code> <p>Defines the mass of the particle/system of interest. Default is 1.0 au.</p> <code>1.0</code> <code>omega</code> <code>float</code> <p>Frequency of harmonic oscillator. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n             omega: float = 1.0) -&gt; None:\n    \"\"\"\n    Args:\n        n_basis (int): Number of states to include in the chosen representation. If basis\n            = 'ladder', this is the Fock cutoff and defines the number of states\n            used for representing the ladder operators. If basis = 'coordinate',\n            this defines the number of points for the position and momenta.\n\n        xo (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 Bohr.\n\n        po (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 au.\n\n        mass (float, optional): Defines the mass of the particle/system of interest.\n            Default is 1.0 au.\n\n        omega (float, optional): Frequency of harmonic oscillator.\n            Default is 1.0 au.\n\n    \"\"\"\n    #--------- Required Attributes Populated During Execution ----------#\n    self.n_basis                   = n_basis\n    self.xo                        = xo\n    self.po                        = po\n    self.mass                      = mass\n    self.hbar                      = 1.0\n    self.omega                     = omega\n    #--------- Below are Attributes Populated During Execution ---------#\n    self.total_time                = 0.\n    self.n_tsteps                  = 0.\n    self._KE_op                    = None\n    self._PE_op                    = None\n    self.H_op                      = None\n    self.prop_KE_op                = None\n    self.prop_PE_op                = None\n    self.prop_H_op                 = None\n    # Grid operators\n    self._KE_grid                  = None\n    self._PE_grid                  = None\n    self.H_grid                    = None\n    self.PE_prop_grid              = None\n    self.KE_prop_grid              = None\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS._get_pgrid","title":"<code>_get_pgrid(x_min, x_max, reorder=True)</code>","text":"<p>Populate the <code>self.p_grid</code> and <code>self.dp</code> attributes. This function generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum value of x-coordinates</p> required <code>x_max</code> <code>float</code> <p>Maximum value of x-coordinates</p> required <code>reorder</code> <code>bool</code> <p>Boolean flag to determine whether points should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dp (float): Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid (array_like): Array of momentum grid points</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.p_grid` and `self.dp` attributes. This function\n    generates an array of `self.n_basis` evenly spaced values.\n\n    Args:\n        x_min (float): Minimum value of x-coordinates\n        x_max (float): Maximum value of x-coordinates\n        reorder (bool): Boolean flag to determine whether points should be reordered to be\n            compatible with the FFT routine or not.\n\n    Returns:\n        self.dp (float): Spacing between points in the p-coordinate grid.\n        self.pgrid (array_like): Array of momentum grid points\n    \"\"\"\n    dp = 2 * np.pi / (x_max - x_min)\n    pmin = -dp * self.n_basis / 2\n    pmax = dp * self.n_basis / 2\n    plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n    minus_pgrid = - np.flip(np.copy(plus_pgrid))\n    if reorder:\n        p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n    else:\n        p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n    self.p_grid = p_grid\n    self.dp = dp\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS._get_xgrid","title":"<code>_get_xgrid(x_min, x_max)</code>","text":"<p>Populate the <code>self.x_grid</code> and <code>self.dx</code> attributes. This function generates an array of <code>self.n_basis</code> evenly spaced values between <code>x_min</code> and <code>x_max</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum value of x-coordinates</p> required <code>x_max</code> <code>float</code> <p>Maximum value of x-coordinates</p> required <p>Returns:</p> Type Description <code>None</code> <p>self.dx (float): Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid` and `self.dx` attributes. This function\n    generates an array of `self.n_basis` evenly spaced values between\n    `x_min` and `x_max`.\n\n    Args:\n        x_min (float): Minimum value of x-coordinates\n        x_max (float): Maximum value of x-coordinates\n\n    Returns:\n        self.dx (float): Spacing between points in the x-coordinate grid.\n        self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n    \"\"\"\n    dx = (x_max - x_min) / self.n_basis\n    x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n    self.dx = dx\n    self.x_grid = x_grid\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.custom_grid_state_initialization","title":"<code>custom_grid_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized grid state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized grid state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return an array\n    \"\"\"\n\n    self.psio_grid = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.custom_ladder_state_initialization","title":"<code>custom_ladder_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized ladder state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return a qutip.Qobj.</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized ladder state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return a qutip.Qobj.\n    \"\"\"\n\n    self.psio_op = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.initialize_operators","title":"<code>initialize_operators()</code>","text":"<p>Function to initialize core operators in the chosen basis.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def initialize_operators(self):\n    \"\"\"\n        Function to initialize core operators in the chosen basis.\n\n    \"\"\"\n\n    self.a_op = qt.destroy(self.n_basis)\n    self.x_op = qt.position(self.n_basis)\n    self.p_op = qt.momentum(self.n_basis)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.propagate_SOFT","title":"<code>propagate_SOFT()</code>","text":"<p>Function used to propagate with the 2nd-Order Trotter Expansion.</p> \\[ e^{- \frac{i}{\\hbar} H t} \u0007pprox e^{- \frac{i}{\\hbar} V t/2} e^{- \frac{i}{\\hbar} T t} e^{- \frac{i}{\\hbar} V t/2} + \\mathcal{O}^{3} \\] <p>Returns:</p> Name Type Description <code>dynamics_results_grid</code> <code>array - like</code> <p>array containing the propagated state                                 shape (n_tsteps x self.n_basis)</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_SOFT(self):\n    \"\"\"\n    Function used to propagate with the 2nd-Order Trotter Expansion.\n\n    $$\n    e^{- \\frac{i}{\\\\hbar} H t} \\approx e^{- \\frac{i}{\\\\hbar} V t/2} e^{- \\frac{i}{\\\\hbar} T t} e^{- \\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n    $$\n\n    Returns:\n        dynamics_results_grid (array-like): array containing the propagated state\n                                            shape (n_tsteps x self.n_basis)\n\n    \"\"\"\n    self.tau = self.tlist[1] - self.tlist[0]\n    PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n    KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n    self.PE_prop_grid = PE_prop\n    self.KE_prop_grid = KE_prop\n\n    propagated_states = [self.psio_grid]\n    psi_t = self.psio_grid\n    for ii in range(len(self.tlist)):\n        psi_t_position_grid = PE_prop * psi_t\n        psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n        psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n        propagated_states.append(psi_t)\n\n    self.dynamics_results_grid = np.asarray(propagated_states)[:-1]\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.propagate_qt","title":"<code>propagate_qt(solver_options=None)</code>","text":"<p>Function used to propagate with qutip.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>dict</code> <p>A dictionary of arguments to pass to the qutip.sesolve function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dynamics_results</code> <code>array - like</code> <p>array containing the propagated state</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_qt(self, solver_options : dict = None):\n    \"\"\"\n    Function used to propagate with qutip.\n\n    Args:\n        solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n    Returns:\n        dynamics_results (array-like): array containing the propagated state\n\n    \"\"\"\n\n    options = {'nsteps': len(self.tlist),\n                'progress_bar': True}\n\n    if solver_options:\n        for key in solver_options:\n            options[key] = solver_options[key]\n\n    results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                         options=options)\n\n    self.dynamics_results_op = results\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_H_grid_with_custom_potential","title":"<code>set_H_grid_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the custom potential energy. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the custom potential\n            energy. Must return an array\n\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_grid = potential\n    self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n    self.H_grid = self._PE_grid + self._KE_grid\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_H_op_with_custom_potential","title":"<code>set_H_op_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the potential energy in terms of qutip QObj operators. Must return a qutip.Qobj</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the potential\n            energy in terms of qutip QObj operators. Must return a qutip.Qobj\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_op = potential\n    self._KE_op = self.p_op ** 2 / (2. * self.mass)\n    self.H_op = self._PE_op + self._KE_op\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_coordinate_operators","title":"<code>set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)</code>","text":"<p>Populate the <code>self.x_grid</code>, <code>self.p_grid</code>, <code>self.dx</code>, and <code>self.dp</code> attributes. This functions generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <p>float Minimum value of x-coordinates</p> <code>-7.0</code> <code>x_max</code> <p>float Maximum value of x-coordinates</p> <code>7.0</code> <code>reorder_p</code> <p>bool Boolean flag to determine whether momentum values should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dx : float Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid : array_like Array of x-values</p> <code>None</code> <p>self.dp : float Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid : array_like Array of p-values</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n    attributes. This functions generates an array of `self.n_basis`\n    evenly spaced values.\n\n    Args:\n        x_min : float\n            Minimum value of x-coordinates\n        x_max : float\n            Maximum value of x-coordinates\n        reorder_p : bool\n            Boolean flag to determine whether momentum values should be\n            reordered to be compatible with the FFT routine or not.\n\n    Returns:\n        self.dx : float\n            Spacing between points in the x-coordinate grid.\n        self.xgrid : array_like\n            Array of x-values\n        self.dp : float\n            Spacing between points in the p-coordinate grid.\n        self.pgrid : array_like\n            Array of p-values\n    \"\"\"\n    self._get_xgrid(x_min, x_max)\n    self._get_pgrid(x_min, x_max, reorder=reorder_p)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_hamiltonian","title":"<code>set_hamiltonian(potential_type='harmonic', **kwargs)</code>","text":"<p>Function to define Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>potential_type</code> <p>str String defining the type of potential energy surface. Available options are: ('harmonic', 'quartic', ...)</p> <p>Note: You can manually define your potential energy using the functions:     - set_H_grid_with_custom_potential     - set_H_op_with_custom_potential</p> <code>'harmonic'</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n    \"\"\"\n    Function to define Hamiltonian.\n\n    Args:\n        potential_type : str\n            String defining the type of potential energy surface.\n            Available options are: ('harmonic', 'quartic', ...)\n\n            Note: You can manually define your potential energy using the functions:\n                - set_H_grid_with_custom_potential\n                - set_H_op_with_custom_potential\n\n    \"\"\"\n\n    if potential_type == 'harmonic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    elif potential_type == 'quartic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    else:\n        print('Error, this potential type has not yet been implemented!')\n        print('Set your parameters with the custom functions!')\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_initial_state","title":"<code>set_initial_state(wfn_omega=1.0)</code>","text":"<p>Function to define the initial state. By default, a coherent state is used as the initial state defined in the basis chosen upon instantiation</p> <p>Parameters:</p> Name Type Description Default <code>wfn_omega</code> <code>float</code> <p>Defines the frequency/width of the initial state. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_initial_state(self, wfn_omega: float = 1.0):\n    \"\"\"\n    Function to define the initial state. By default, a coherent state is\n    used as the initial state defined in the basis chosen upon instantiation\n\n    Args:\n        wfn_omega (float, optional): Defines the frequency/width of the initial state.\n            Default is 1.0 au.\n    \"\"\"\n\n    alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n    psio = qt.coherent(self.n_basis, alpha=alpha_val)\n    # Now populate the initial state in the grid basis\n    normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n    exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                         ((self.x_grid - self.xo) ** 2)\n                         + 1j * self.po * self.x_grid / self.hbar\n                         )\n\n    coherent_state = normalization * exponential\n    # Set the attributes\n    self.psio_grid = coherent_state\n    self.psio_op = psio\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_propagation_time","title":"<code>set_propagation_time(total_time, n_tsteps)</code>","text":"<p>Function to define the propagation time, an array of times from t=0 to total_time, with n_tsteps equally-spaced steps.</p> <p>total_time : float     The total time for which we wish to compute the dynamics. n_tsteps : int     The number of equally-spaced time steps used to compute the dynamics</p> <p>Returns: self.tlist : array-like</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_propagation_time(self, total_time: float, n_tsteps: int):\n    \"\"\"\n    Function to define the propagation time, an array of times from\n    t=0 to total_time, with n_tsteps equally-spaced steps.\n\n    Args:\n    total_time : float\n        The total time for which we wish to compute the dynamics.\n    n_tsteps : int\n        The number of equally-spaced time steps used to compute the dynamics\n\n    Returns:\n    self.tlist : array-like\n\n    \"\"\"\n\n    self.tlist = np.linspace(0., total_time, n_tsteps)\n    self.dt = self.tlist[1] - self.tlist[0]\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS","title":"<code>QubitDynamicsCS</code>","text":"<p>               Bases: <code>DynamicsCS</code></p> <p>Class to extend <code>DynamicsCS</code> by adding qubit-based methods for dynamics.</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>class QubitDynamicsCS(DynamicsCS):\n    \"\"\"\n    Class to extend `DynamicsCS` by adding qubit-based methods for dynamics.\n\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.n_qubits        = int(np.log2(self.n_basis))\n        self.quantum_circuit = None\n\n\n    def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n        \"\"\"\n        Function to construct the QSOFT Circuit.\n\n        Args:\n            psio (npt.ArrayLike): initial state that we wish to propagate\n        \"\"\"\n        tgrid = self.tlist\n        time_step = self.dt\n        n_qubits = self.n_qubits\n        # Qubit-Basis Propagators\n        self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n        self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n        q_reg = QuantumRegister(n_qubits)\n        c_reg = ClassicalRegister(n_qubits)\n        qc = QuantumCircuit(q_reg)\n        if type(psio) == type(None):\n            qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n        else:\n            qc.initialize(psio, q_reg[:], normalize=True)\n        # Define our PE and KE propagators in Qiskit-friendly manner\n        PE_cirq_op = Operator(self.prop_PE_qubit)\n        KE_cirq_op = Operator(self.prop_KE_qubit)\n        qc.append(PE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n        qc.append(KE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n        qc.append(PE_cirq_op, q_reg)\n        self.quantum_circuit = qc\n        return(qc)\n\n\n    def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n        \"\"\"\n            Function to replace the now-deprecated Qiskit\n            `QuantumCircuit.execute()` method.\n\n            Args:\n                QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n                backend (qiskit.Backend): qiskit backend instance\n                shots (int): the number of shots to use for circuit sampling\n\n            Returns:\n                job: an executed quantum circuit job\n        \"\"\"\n        if shots:\n            n_shots = shots\n        else:\n            n_shots = 1024 # Use the qiskit default if not specified\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type == sv_type:\n            real_backend = False\n        else:\n            real_backend = True\n\n        if real_backend:\n            QCircuit.measure_all()\n            qc = transpile(QCircuit, backend=backend)\n            sampler = Sampler(backend)\n            job = sampler.run([qc], shots=n_shots)\n        else:\n            # Transpile circuit with statevector backend\n            tmp_circuit = transpile(QCircuit, backend)\n            # Run the transpiled circuit\n            job = backend.run(tmp_circuit, n_shots=shots)\n        return(job)\n\n\n    def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n        \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n        if backend is None:\n            print('A valid backend must be provided ')\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type != sv_type:\n            self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n            return\n        else:\n\n            psi_in = self.psio_grid\n            # Get initial state from qiskit routine\n            q_reg = QuantumRegister(self.n_qubits)\n            c_reg = ClassicalRegister(self.n_qubits)\n            qc = QuantumCircuit(q_reg, c_reg)\n            qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n            qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n            psio_cirq = qc_result.result().get_statevector().data\n            # Now do propagation loop\n            qubit_dynamics_results = [psio_cirq]\n            for ii in trange(len(self.tlist)):\n                circuit = self._create_QSOFT_Circuit(psio=psi_in)\n                executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n                psi_out = executed_circuit.result().get_statevector().data\n                qubit_dynamics_results.append(psi_out)\n                psi_in = psi_out\n\n            self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n            return\n\n\n    def get_statevector_from_counts(self, counts, n_shots):\n        new_statevector = np.zeros_like(self.psio_grid)\n\n        for key in counts:\n            little_endian_int = int(key, 2)\n            new_statevector[little_endian_int] = counts[key]/n_shots\n        return(new_statevector)\n\n\n    def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n        \"\"\"\n            Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits, name='c')\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        # Now do propagation loop\n        qubit_dynamics_results = []\n        for ii in trange(len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            circuit_result = executed_circuit.result()\n            measured_psi = circuit_result[0].data['meas'].get_counts()\n            self._last_measurement = measured_psi\n            psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n            psi_in = psi_out\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n        return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS._create_QSOFT_Circuit","title":"<code>_create_QSOFT_Circuit(psio=None)</code>","text":"<p>Function to construct the QSOFT Circuit.</p> <p>Parameters:</p> Name Type Description Default <code>psio</code> <code>ArrayLike</code> <p>initial state that we wish to propagate</p> <code>None</code> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n    \"\"\"\n    Function to construct the QSOFT Circuit.\n\n    Args:\n        psio (npt.ArrayLike): initial state that we wish to propagate\n    \"\"\"\n    tgrid = self.tlist\n    time_step = self.dt\n    n_qubits = self.n_qubits\n    # Qubit-Basis Propagators\n    self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n    self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n    q_reg = QuantumRegister(n_qubits)\n    c_reg = ClassicalRegister(n_qubits)\n    qc = QuantumCircuit(q_reg)\n    if type(psio) == type(None):\n        qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n    else:\n        qc.initialize(psio, q_reg[:], normalize=True)\n    # Define our PE and KE propagators in Qiskit-friendly manner\n    PE_cirq_op = Operator(self.prop_PE_qubit)\n    KE_cirq_op = Operator(self.prop_KE_qubit)\n    qc.append(PE_cirq_op, q_reg)\n    qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n    qc.append(KE_cirq_op, q_reg)\n    qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n    qc.append(PE_cirq_op, q_reg)\n    self.quantum_circuit = qc\n    return(qc)\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS._execute_circuit","title":"<code>_execute_circuit(QCircuit, backend=None, shots=None, real_backend=False)</code>","text":"<p>Function to replace the now-deprecated Qiskit <code>QuantumCircuit.execute()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>QCircuit</code> <code>QuantumCircuit</code> <p>qiskit.QuantumCircuit object</p> required <code>backend</code> <code>Backend</code> <p>qiskit backend instance</p> <code>None</code> <code>shots</code> <code>int</code> <p>the number of shots to use for circuit sampling</p> <code>None</code> <p>Returns:</p> Name Type Description <code>job</code> <p>an executed quantum circuit job</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n    \"\"\"\n        Function to replace the now-deprecated Qiskit\n        `QuantumCircuit.execute()` method.\n\n        Args:\n            QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n            backend (qiskit.Backend): qiskit backend instance\n            shots (int): the number of shots to use for circuit sampling\n\n        Returns:\n            job: an executed quantum circuit job\n    \"\"\"\n    if shots:\n        n_shots = shots\n    else:\n        n_shots = 1024 # Use the qiskit default if not specified\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type == sv_type:\n        real_backend = False\n    else:\n        real_backend = True\n\n    if real_backend:\n        QCircuit.measure_all()\n        qc = transpile(QCircuit, backend=backend)\n        sampler = Sampler(backend)\n        job = sampler.run([qc], shots=n_shots)\n    else:\n        # Transpile circuit with statevector backend\n        tmp_circuit = transpile(QCircuit, backend)\n        # Run the transpiled circuit\n        job = backend.run(tmp_circuit, n_shots=shots)\n    return(job)\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS._propagate_qSOFT_real","title":"<code>_propagate_qSOFT_real(backend='statevector_simulator', n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>'statevector_simulator'</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n    \"\"\"\n        Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n\n\n    psi_in = self.psio_grid\n    # Get initial state from qiskit routine\n    q_reg = QuantumRegister(self.n_qubits)\n    c_reg = ClassicalRegister(self.n_qubits, name='c')\n    qc = QuantumCircuit(q_reg, c_reg)\n    qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n    # Now do propagation loop\n    qubit_dynamics_results = []\n    for ii in trange(len(self.tlist)):\n        circuit = self._create_QSOFT_Circuit(psio=psi_in)\n        executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n        circuit_result = executed_circuit.result()\n        measured_psi = circuit_result[0].data['meas'].get_counts()\n        self._last_measurement = measured_psi\n        psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n        psi_in = psi_out\n        qubit_dynamics_results.append(psi_out)\n        psi_in = psi_out\n\n    self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS.propagate_qSOFT","title":"<code>propagate_qSOFT(backend=None, n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>None</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n    \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n    if backend is None:\n        print('A valid backend must be provided ')\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type != sv_type:\n        self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n        return\n    else:\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n        psio_cirq = qc_result.result().get_statevector().data\n        # Now do propagation loop\n        qubit_dynamics_results = [psio_cirq]\n        for ii in trange(len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            psi_out = executed_circuit.result().get_statevector().data\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n        return\n</code></pre>"},{"location":"qflux/hello/","title":"Hello module","text":""},{"location":"qflux/hello/#source-code","title":"Source Code","text":""},{"location":"qflux/open_systems/","title":"Open Systems Module","text":""},{"location":"qflux/open_systems/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>open_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/open_systems/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/open_systems/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/open_systems/#source-code","title":"Source Code","text":""},{"location":"qflux/open_systems/#qflux.open_systems","title":"<code>qflux.open_systems</code>","text":""},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS","title":"<code>DynamicsOS</code>","text":"<p>Class for open-system dynamics (Lindblad equation).</p> <p>This class provides methods to simulate open-system dynamics described by the Lindblad equation.</p> <p>Attributes:</p> Name Type Description <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system (shape (N, N)).</p> <code>rho0</code> <code>ndarray</code> <p>Initial density matrix (shape (N, N)).</p> <code>c_ops</code> <code>List[ndarray]</code> <p>List of collapse operators (each of shape (N, N)).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DynamicsOS:\n    \"\"\"Class for open-system dynamics (Lindblad equation).\n\n    This class provides methods to simulate open-system dynamics described by the Lindblad equation.\n\n    Attributes:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system (shape (N, N)).\n        rho0 (np.ndarray): Initial density matrix (shape (N, N)).\n        c_ops (List[np.ndarray]): List of collapse operators (each of shape (N, N)).\n    \"\"\"\n\n    def __init__(\n        self,\n        Nsys: int,\n        Hsys: np.ndarray,\n        rho0: np.ndarray,\n        c_ops: Optional[List[np.ndarray]] = None\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DynamicsOS instance.\n\n        Args:\n            Nsys (int): System Hilbert Space Dimension.\n            Hsys (np.ndarray): Hamiltonian of the system.\n            rho0 (np.ndarray): Initial density matrix.\n            c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n        \"\"\"\n        if c_ops is None:\n            c_ops = []\n        self.Nsys: int = Nsys\n        self.Hsys: np.ndarray = Hsys\n        self.rho0: np.ndarray = rho0\n        self.c_ops: List[np.ndarray] = c_ops\n\n    def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n        \"\"\"\n        Compute the propagator of the Lindblad equation using the matrix exponential.\n\n        The propagator is computed by exponentiating the Liouvillian operator defined by the\n        system Hamiltonian and collapse operators.\n\n        Args:\n            time_arr (List[float]): Array of time values for the simulation.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n        Returns:\n            List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n        \"\"\"\n        ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n        # Build the A matrix for time-derivation of the vectorized density matrix.\n        Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n        for i in range(len(self.c_ops)):\n            Amat += 0.5 * (\n                2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n                - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n                - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n            )\n\n        G_prop: List[np.ndarray] = []\n        for i, t in enumerate(time_arr):\n            if Is_show_step:\n                print(\"step\", i, \"time\", t)\n            Gt: np.ndarray = LA.expm(Amat * t)\n            G_prop.append(Gt)\n        return G_prop\n\n    def propagate_matrix_exp(\n        self,\n        time_arr: List[float],\n        observable: np.ndarray,\n        Is_store_state: bool = False,\n        Is_show_step: bool = False,\n        Is_Gt: bool = False,\n    ) -&gt; Any:\n        \"\"\"\n        Solve the Lindblad equation using matrix exponential.\n\n        This method computes the propagator, evolves the initial density matrix, and calculates\n        the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (np.ndarray): Observable matrix for which the expectation value is computed.\n            Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                             Defaults to False.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n            Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n        Returns:\n            Result: An object with the following attributes:\n                - expect (List[float]): List of expectation values over time.\n                - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n                - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n        \"\"\"\n\n        class Result:\n            \"\"\"Class for storing propagation results.\"\"\"\n            def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n                self.expect: List[float] = []\n                if store_state:\n                    self.density_matrix: List[np.ndarray] = []\n                if include_Gt:\n                    self.Gprop: Optional[List[np.ndarray]] = None\n\n        result = Result(Is_store_state, Is_Gt)\n\n        # Compute the propagator of the Lindblad equation.\n        G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n        if Is_Gt:\n            result.Gprop = G_prop\n\n        # Initialize the vectorized density matrix.\n        vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n        for i, _ in enumerate(time_arr):\n            vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n            # Reshape back to density matrix form.\n            rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n            if Is_store_state:\n                result.density_matrix.append(rhot)\n            result.expect.append(np.trace(rhot @ observable).real)\n\n        return result\n\n    def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n        \"\"\"\n        Propagate the system using QuTiP's `mesolve` function.\n\n        This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n        values of the observable over time.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (Any): Observable operator(s) for which the expectation value is computed.\n                              Can be a single operator or a list of operators.\n            **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n        Returns:\n            List[float]: List of expectation values of the observable over time.\n        \"\"\"\n        c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n        if isinstance(observable, list):\n            obs = [Qobj(op) for op in observable]\n        else:\n            obs = Qobj(observable)\n\n        result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n        return result.expect\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.Gt_matrix_expo","title":"<code>Gt_matrix_expo(time_arr, Is_show_step=False)</code>","text":"<p>Compute the propagator of the Lindblad equation using the matrix exponential.</p> <p>The propagator is computed by exponentiating the Liouvillian operator defined by the system Hamiltonian and collapse operators.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Array of time values for the simulation.</p> required <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: List of propagators corresponding to each time in <code>time_arr</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n    \"\"\"\n    Compute the propagator of the Lindblad equation using the matrix exponential.\n\n    The propagator is computed by exponentiating the Liouvillian operator defined by the\n    system Hamiltonian and collapse operators.\n\n    Args:\n        time_arr (List[float]): Array of time values for the simulation.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n    Returns:\n        List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n    \"\"\"\n    ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n    # Build the A matrix for time-derivation of the vectorized density matrix.\n    Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n    for i in range(len(self.c_ops)):\n        Amat += 0.5 * (\n            2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n            - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n            - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n        )\n\n    G_prop: List[np.ndarray] = []\n    for i, t in enumerate(time_arr):\n        if Is_show_step:\n            print(\"step\", i, \"time\", t)\n        Gt: np.ndarray = LA.expm(Amat * t)\n        G_prop.append(Gt)\n    return G_prop\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.__init__","title":"<code>__init__(Nsys, Hsys, rho0, c_ops=None)</code>","text":"<p>Initialize the DynamicsOS instance.</p> <p>Parameters:</p> Name Type Description Default <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> required <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system.</p> required <code>rho0</code> <code>ndarray</code> <p>Initial density matrix.</p> required <code>c_ops</code> <code>Optional[List[ndarray]]</code> <p>List of collapse operators. Defaults to an empty list.</p> <code>None</code> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(\n    self,\n    Nsys: int,\n    Hsys: np.ndarray,\n    rho0: np.ndarray,\n    c_ops: Optional[List[np.ndarray]] = None\n) -&gt; None:\n    \"\"\"\n    Initialize the DynamicsOS instance.\n\n    Args:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system.\n        rho0 (np.ndarray): Initial density matrix.\n        c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n    \"\"\"\n    if c_ops is None:\n        c_ops = []\n    self.Nsys: int = Nsys\n    self.Hsys: np.ndarray = Hsys\n    self.rho0: np.ndarray = rho0\n    self.c_ops: List[np.ndarray] = c_ops\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.propagate_matrix_exp","title":"<code>propagate_matrix_exp(time_arr, observable, Is_store_state=False, Is_show_step=False, Is_Gt=False)</code>","text":"<p>Solve the Lindblad equation using matrix exponential.</p> <p>This method computes the propagator, evolves the initial density matrix, and calculates the expectation value of the observable over time. Optionally, it stores the evolved density matrices.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>ndarray</code> <p>Observable matrix for which the expectation value is computed.</p> required <code>Is_store_state</code> <code>bool</code> <p>If True, stores the density matrices at each time step.                              Defaults to False.</p> <code>False</code> <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <code>Is_Gt</code> <code>bool</code> <p>If True, includes the propagators in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Any</code> <p>An object with the following attributes: - expect (List[float]): List of expectation values over time. - density_matrix (List[np.ndarray], optional): List of density matrices (if <code>Is_store_state</code> is True). - Gprop (List[np.ndarray], optional): List of propagators (if <code>Is_Gt</code> is True).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_matrix_exp(\n    self,\n    time_arr: List[float],\n    observable: np.ndarray,\n    Is_store_state: bool = False,\n    Is_show_step: bool = False,\n    Is_Gt: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Solve the Lindblad equation using matrix exponential.\n\n    This method computes the propagator, evolves the initial density matrix, and calculates\n    the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (np.ndarray): Observable matrix for which the expectation value is computed.\n        Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                         Defaults to False.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n        Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n    Returns:\n        Result: An object with the following attributes:\n            - expect (List[float]): List of expectation values over time.\n            - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n            - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n    \"\"\"\n\n    class Result:\n        \"\"\"Class for storing propagation results.\"\"\"\n        def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n            self.expect: List[float] = []\n            if store_state:\n                self.density_matrix: List[np.ndarray] = []\n            if include_Gt:\n                self.Gprop: Optional[List[np.ndarray]] = None\n\n    result = Result(Is_store_state, Is_Gt)\n\n    # Compute the propagator of the Lindblad equation.\n    G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n    if Is_Gt:\n        result.Gprop = G_prop\n\n    # Initialize the vectorized density matrix.\n    vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n    for i, _ in enumerate(time_arr):\n        vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n        # Reshape back to density matrix form.\n        rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n        if Is_store_state:\n            result.density_matrix.append(rhot)\n        result.expect.append(np.trace(rhot @ observable).real)\n\n    return result\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.propagate_qt","title":"<code>propagate_qt(time_arr, observable, **kwargs)</code>","text":"<p>Propagate the system using QuTiP's <code>mesolve</code> function.</p> <p>This method solves the Lindblad master equation using QuTiP's <code>mesolve</code> to compute the expectation values of the observable over time.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>Any</code> <p>Observable operator(s) for which the expectation value is computed.               Can be a single operator or a list of operators.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to <code>mesolve</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of expectation values of the observable over time.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n    \"\"\"\n    Propagate the system using QuTiP's `mesolve` function.\n\n    This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n    values of the observable over time.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (Any): Observable operator(s) for which the expectation value is computed.\n                          Can be a single operator or a list of operators.\n        **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n    Returns:\n        List[float]: List of expectation values of the observable over time.\n    \"\"\"\n    c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n    if isinstance(observable, list):\n        obs = [Qobj(op) for op in observable]\n    else:\n        obs = Qobj(observable)\n\n    result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n    return result.expect\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS","title":"<code>QubitDynamicsOS</code>","text":"<p>               Bases: <code>DynamicsOS</code></p> <p>Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.</p> <p>This class provides methods to initialize state vectors, construct quantum circuits, and perform quantum simulations using Qiskit backends.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>class QubitDynamicsOS(DynamicsOS):\n    \"\"\"\n    Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.\n\n    This class provides methods to initialize state vectors, construct quantum circuits,\n    and perform quantum simulations using Qiskit backends.\n    \"\"\"\n\n    def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize a QubitDynamicsOS instance.\n\n        Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n        Additional keyword arguments are passed to the base DynamicsOS class.\n\n        Args:\n            rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n            **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if rep == 'Density':\n            # Vectorized density matrix representation\n            self.rep: str = 'Density'\n            self.Nqb: int = int(np.log2(self.Nsys**2))\n        elif rep == 'Kraus':\n            # Kraus operator representation\n            self.rep = 'Kraus'\n            self.Nqb = int(np.log2(self.Nsys))\n\n        # The counting qubits bit string and observable matrix are initialized to None.\n        self.count_str: Optional[List[str]] = None\n        self.observable: Optional[np.ndarray] = None\n\n        # Default dilation method for quantum simulation.\n        self.dilation_method: str = 'Sz-Nagy'\n\n    def set_dilation_method(self, method: str) -&gt; None:\n        \"\"\"\n        Set the dilation method for quantum simulation.\n\n        Args:\n            method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n        \"\"\"\n        self.dilation_method = method\n\n    def set_count_str(self, count_str: List[str]) -&gt; None:\n        \"\"\"\n        Set the counting bit string for measurement.\n\n        Args:\n            count_str (List[str]): The counting bit string.\n        \"\"\"\n        self.count_str = count_str\n\n    def set_observable(self, observable: np.ndarray) -&gt; None:\n        \"\"\"\n        Set the observable for the quantum simulation.\n\n        Args:\n            observable (np.ndarray): The observable matrix.\n        \"\"\"\n        self.observable = observable\n\n    def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n        \"\"\"\n        Initialize the state vector from the initial density operator using vectorized representation.\n\n        The initial density matrix is reshaped into a vector and normalized.\n\n        Returns:\n            Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n            of the original vectorized density matrix.\n        \"\"\"\n        vec_rho0 = self.rho0.reshape(self.Nsys**2)\n        norm0 = LA.norm(vec_rho0, 2)\n        statevec = vec_rho0 / norm0\n        return statevec, norm0\n\n    def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n        \"\"\"\n        Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n        The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n        below the specified tolerance are ignored.\n\n        Args:\n            tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n        Returns:\n            Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n            corresponding probabilities.\n        \"\"\"\n        eigenvalues, eigenvectors = LA.eigh(self.rho0)\n        statevec: List[np.ndarray] = []\n        prob: List[float] = []\n        for i in range(len(eigenvalues) - 1, -1, -1):\n            if abs(eigenvalues[i]) &lt; tol:\n                break\n            prob.append(eigenvalues[i])\n            statevec.append(eigenvectors[:, i])\n        return statevec, prob\n\n    def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n        \"\"\"\n        Prepare and return the Qiskit observable operator.\n\n        Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n        Args:\n            Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n                Defaults to False.\n            tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n        Returns:\n            SparsePauliOp: The Qiskit representation of the observable.\n        \"\"\"\n        if self.observable is None:\n            print('Error: observable is None')\n\n        if Isdilate:\n            num_qubits = self.Nqb + 1\n            Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n            Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n        else:\n            num_qubits = self.Nqb\n            Obs_mat = self.observable\n\n        Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n        # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n        data: List[str] = []\n        coef: List[float] = []\n        for key in Obs_paulis_dic:\n            data.append(key)\n            coef.append(Obs_paulis_dic[key])\n        obs_q = SparsePauliOp(data, coef)\n        return obs_q\n\n    def qc_simulation_kraus(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n        Gprop: Optional[List[np.ndarray]] = None,\n        tolk: float = 1e-5,\n        tolo: float = 1e-5,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the Kraus operator representation.\n\n        This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n        It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n        and accumulates the measurement results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of shots for each measurement. Defaults to 1024.\n            Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n                If None, Kraus operators are generated from the propagator. Defaults to None.\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n            tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            np.ndarray: Array containing the quantum simulation results.\n        \"\"\"\n        nsteps = len(time_arr)\n\n        # Generate Kraus operators if not provided.\n        if Kraus is None:\n            Kraus = {}\n            if Gprop is None:\n                print('Calculating the propagator')\n                Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n            print('Generating the Kraus operators')\n            for i in range(nsteps):\n                print('At step', i, 'of', nsteps)\n                Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n        print('Kraus operator generation complete')\n\n        # Perform Qiskit simulation using the Estimator.\n        estimator = Estimator()\n\n        statevec, prob = self.init_statevec_Kraus()\n        n_inistate = len(statevec)\n        print('Number of initial states in the density matrix:', n_inistate)\n        print('Probabilities:', prob)\n\n        # Obtain the Qiskit observable.\n        obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n        print('Starting quantum simulation')\n        result_simulation = np.zeros(nsteps, dtype=np.float64)\n\n        for i in range(nsteps):\n            print('Simulation step', i, 'of', nsteps)\n            current_kraus_list = Kraus[i]\n            print('Number of Kraus operators:', len(current_kraus_list))\n            for kraus_op in current_kraus_list:\n                for istate in range(n_inistate):\n                    qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                    result = estimator.run(qc, obs_q, shots=shots).result()\n                    result_simulation[i] += result.values[0] * prob[istate]\n\n        return result_simulation\n\n    def qc_simulation_vecdens(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        backend: Any = AerSimulator(),\n        Gprop: Optional[List[np.ndarray]] = None,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the vectorized density matrix representation.\n\n        This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n        based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of measurement shots. Defaults to 1024.\n            backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            np.ndarray: Array containing the quantum simulation results.\n        \"\"\"\n        if Gprop is None:\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n        nsteps = len(time_arr)\n\n        if self.count_str is None:\n            print(\"Error: count_str is not assigned\")\n\n        n_bitstr = len(self.count_str)\n        statevec, norm0 = self.init_statevec_vecdens()\n        result = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n\n        for i in range(nsteps):\n            if i % 100 == 0:\n                print('Quantum simulation step', i)\n            Gt = Gprop[i]\n            circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n            circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n            if self.dilation_method == 'SVD-Walsh':\n                circuit = transpile(circuit, backend)\n            counts = backend.run(circuit, shots=shots).result().get_counts()\n            for j in range(n_bitstr):\n                bitstr = self.count_str[j]\n                if bitstr in counts:\n                    result[i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n                else:\n                    print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n        return result\n\n    def _create_circuit(\n        self,\n        array: np.ndarray,\n        statevec: Union[np.ndarray, List[np.ndarray]],\n        Isscale: bool = True\n    ) -&gt; QuantumCircuit:\n        \"\"\"\n        Construct and return the quantum circuit.\n\n        This method wraps the call to the dilation circuit construction function.\n\n        Args:\n            array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n            statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n            Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n        Returns:\n            QuantumCircuit: The constructed quantum circuit.\n        \"\"\"\n        return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.__init__","title":"<code>__init__(rep='Density', **kwargs)</code>","text":"<p>Initialize a QubitDynamicsOS instance.</p> <p>Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed. Additional keyword arguments are passed to the base DynamicsOS class.</p> <p>Parameters:</p> Name Type Description Default <code>rep</code> <code>str</code> <p>Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.</p> <code>'Density'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the DynamicsOS initializer.</p> <code>{}</code> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize a QubitDynamicsOS instance.\n\n    Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n    Additional keyword arguments are passed to the base DynamicsOS class.\n\n    Args:\n        rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n        **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if rep == 'Density':\n        # Vectorized density matrix representation\n        self.rep: str = 'Density'\n        self.Nqb: int = int(np.log2(self.Nsys**2))\n    elif rep == 'Kraus':\n        # Kraus operator representation\n        self.rep = 'Kraus'\n        self.Nqb = int(np.log2(self.Nsys))\n\n    # The counting qubits bit string and observable matrix are initialized to None.\n    self.count_str: Optional[List[str]] = None\n    self.observable: Optional[np.ndarray] = None\n\n    # Default dilation method for quantum simulation.\n    self.dilation_method: str = 'Sz-Nagy'\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS._create_circuit","title":"<code>_create_circuit(array, statevec, Isscale=True)</code>","text":"<p>Construct and return the quantum circuit.</p> <p>This method wraps the call to the dilation circuit construction function.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Array used for circuit construction (e.g., propagator or Kraus operator).</p> required <code>statevec</code> <code>Union[ndarray, List[ndarray]]</code> <p>State vector(s) to be used in the circuit.</p> required <code>Isscale</code> <code>bool</code> <p>Flag indicating whether scaling should be applied. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QuantumCircuit</code> <code>QuantumCircuit</code> <p>The constructed quantum circuit.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def _create_circuit(\n    self,\n    array: np.ndarray,\n    statevec: Union[np.ndarray, List[np.ndarray]],\n    Isscale: bool = True\n) -&gt; QuantumCircuit:\n    \"\"\"\n    Construct and return the quantum circuit.\n\n    This method wraps the call to the dilation circuit construction function.\n\n    Args:\n        array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n        statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n        Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n    Returns:\n        QuantumCircuit: The constructed quantum circuit.\n    \"\"\"\n    return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS._get_qiskit_observable","title":"<code>_get_qiskit_observable(Isdilate=False, tol=0.005)</code>","text":"<p>Prepare and return the Qiskit observable operator.</p> <p>Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.</p> <p>Parameters:</p> Name Type Description Default <code>Isdilate</code> <code>bool</code> <p>Flag indicating whether to use the dilated observable. Defaults to False.</p> <code>False</code> <code>tol</code> <code>float</code> <p>Tolerance for the Pauli decomposition. Defaults to 5e-3.</p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>SparsePauliOp</code> <code>SparsePauliOp</code> <p>The Qiskit representation of the observable.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n    \"\"\"\n    Prepare and return the Qiskit observable operator.\n\n    Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n    Args:\n        Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n            Defaults to False.\n        tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n    Returns:\n        SparsePauliOp: The Qiskit representation of the observable.\n    \"\"\"\n    if self.observable is None:\n        print('Error: observable is None')\n\n    if Isdilate:\n        num_qubits = self.Nqb + 1\n        Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n        Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n    else:\n        num_qubits = self.Nqb\n        Obs_mat = self.observable\n\n    Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n    # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n    data: List[str] = []\n    coef: List[float] = []\n    for key in Obs_paulis_dic:\n        data.append(key)\n        coef.append(Obs_paulis_dic[key])\n    obs_q = SparsePauliOp(data, coef)\n    return obs_q\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.init_statevec_Kraus","title":"<code>init_statevec_Kraus(tol=1e-06)</code>","text":"<p>Initialize state vectors from the initial density operator using the Kraus operator representation.</p> <p>The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues below the specified tolerance are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of</p> <code>List[float]</code> <p>corresponding probabilities.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n    \"\"\"\n    Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n    The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n    below the specified tolerance are ignored.\n\n    Args:\n        tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n    Returns:\n        Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n        corresponding probabilities.\n    \"\"\"\n    eigenvalues, eigenvectors = LA.eigh(self.rho0)\n    statevec: List[np.ndarray] = []\n    prob: List[float] = []\n    for i in range(len(eigenvalues) - 1, -1, -1):\n        if abs(eigenvalues[i]) &lt; tol:\n            break\n        prob.append(eigenvalues[i])\n        statevec.append(eigenvectors[:, i])\n    return statevec, prob\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.init_statevec_vecdens","title":"<code>init_statevec_vecdens()</code>","text":"<p>Initialize the state vector from the initial density operator using vectorized representation.</p> <p>The initial density matrix is reshaped into a vector and normalized.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm</p> <code>float</code> <p>of the original vectorized density matrix.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Initialize the state vector from the initial density operator using vectorized representation.\n\n    The initial density matrix is reshaped into a vector and normalized.\n\n    Returns:\n        Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n        of the original vectorized density matrix.\n    \"\"\"\n    vec_rho0 = self.rho0.reshape(self.Nsys**2)\n    norm0 = LA.norm(vec_rho0, 2)\n    statevec = vec_rho0 / norm0\n    return statevec, norm0\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.qc_simulation_kraus","title":"<code>qc_simulation_kraus(time_arr, shots=1024, Kraus=None, Gprop=None, tolk=1e-05, tolo=1e-05, **kwargs)</code>","text":"<p>Perform quantum simulation using the Kraus operator representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach. It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator, and accumulates the measurement results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of shots for each measurement. Defaults to 1024.</p> <code>1024</code> <code>Kraus</code> <code>Optional[Dict[int, List[ndarray]]]</code> <p>Dictionary mapping time step index to a list of Kraus operators. If None, Kraus operators are generated from the propagator. Defaults to None.</p> <code>None</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>tolk</code> <code>float</code> <p>Tolerance for generating Kraus operators. Defaults to 1e-5.</p> <code>1e-05</code> <code>tolo</code> <code>float</code> <p>Tolerance for observable decomposition. Defaults to 1e-5.</p> <code>1e-05</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing the quantum simulation results.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_kraus(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n    Gprop: Optional[List[np.ndarray]] = None,\n    tolk: float = 1e-5,\n    tolo: float = 1e-5,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the Kraus operator representation.\n\n    This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n    It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n    and accumulates the measurement results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of shots for each measurement. Defaults to 1024.\n        Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n            If None, Kraus operators are generated from the propagator. Defaults to None.\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n        tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        np.ndarray: Array containing the quantum simulation results.\n    \"\"\"\n    nsteps = len(time_arr)\n\n    # Generate Kraus operators if not provided.\n    if Kraus is None:\n        Kraus = {}\n        if Gprop is None:\n            print('Calculating the propagator')\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n        print('Generating the Kraus operators')\n        for i in range(nsteps):\n            print('At step', i, 'of', nsteps)\n            Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n    print('Kraus operator generation complete')\n\n    # Perform Qiskit simulation using the Estimator.\n    estimator = Estimator()\n\n    statevec, prob = self.init_statevec_Kraus()\n    n_inistate = len(statevec)\n    print('Number of initial states in the density matrix:', n_inistate)\n    print('Probabilities:', prob)\n\n    # Obtain the Qiskit observable.\n    obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n    print('Starting quantum simulation')\n    result_simulation = np.zeros(nsteps, dtype=np.float64)\n\n    for i in range(nsteps):\n        print('Simulation step', i, 'of', nsteps)\n        current_kraus_list = Kraus[i]\n        print('Number of Kraus operators:', len(current_kraus_list))\n        for kraus_op in current_kraus_list:\n            for istate in range(n_inistate):\n                qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                result = estimator.run(qc, obs_q, shots=shots).result()\n                result_simulation[i] += result.values[0] * prob[istate]\n\n    return result_simulation\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.qc_simulation_vecdens","title":"<code>qc_simulation_vecdens(time_arr, shots=1024, backend=AerSimulator(), Gprop=None, **kwargs)</code>","text":"<p>Perform quantum simulation using the vectorized density matrix representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps by constructing circuits based on the vectorized density matrix representation, performing measurements, and processing the results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots. Defaults to 1024.</p> <code>1024</code> <code>backend</code> <code>Any</code> <p>Quantum simulation backend. Defaults to AerSimulator().</p> <code>AerSimulator()</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing the quantum simulation results.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_vecdens(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    backend: Any = AerSimulator(),\n    Gprop: Optional[List[np.ndarray]] = None,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the vectorized density matrix representation.\n\n    This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n    based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of measurement shots. Defaults to 1024.\n        backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        np.ndarray: Array containing the quantum simulation results.\n    \"\"\"\n    if Gprop is None:\n        Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n    nsteps = len(time_arr)\n\n    if self.count_str is None:\n        print(\"Error: count_str is not assigned\")\n\n    n_bitstr = len(self.count_str)\n    statevec, norm0 = self.init_statevec_vecdens()\n    result = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n\n    for i in range(nsteps):\n        if i % 100 == 0:\n            print('Quantum simulation step', i)\n        Gt = Gprop[i]\n        circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n        circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n        if self.dilation_method == 'SVD-Walsh':\n            circuit = transpile(circuit, backend)\n        counts = backend.run(circuit, shots=shots).result().get_counts()\n        for j in range(n_bitstr):\n            bitstr = self.count_str[j]\n            if bitstr in counts:\n                result[i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n            else:\n                print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n    return result\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.set_count_str","title":"<code>set_count_str(count_str)</code>","text":"<p>Set the counting bit string for measurement.</p> <p>Parameters:</p> Name Type Description Default <code>count_str</code> <code>List[str]</code> <p>The counting bit string.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_count_str(self, count_str: List[str]) -&gt; None:\n    \"\"\"\n    Set the counting bit string for measurement.\n\n    Args:\n        count_str (List[str]): The counting bit string.\n    \"\"\"\n    self.count_str = count_str\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.set_dilation_method","title":"<code>set_dilation_method(method)</code>","text":"<p>Set the dilation method for quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_dilation_method(self, method: str) -&gt; None:\n    \"\"\"\n    Set the dilation method for quantum simulation.\n\n    Args:\n        method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n    \"\"\"\n    self.dilation_method = method\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.set_observable","title":"<code>set_observable(observable)</code>","text":"<p>Set the observable for the quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>observable</code> <code>ndarray</code> <p>The observable matrix.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_observable(self, observable: np.ndarray) -&gt; None:\n    \"\"\"\n    Set the observable for the quantum simulation.\n\n    Args:\n        observable (np.ndarray): The observable matrix.\n    \"\"\"\n    self.observable = observable\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid","title":"<code>DVR_grid</code>","text":"<p>Class for Discrete Variable Representation (DVR) grid methods.</p> <p>This class handles grid-based representations for systems where the potential is expressed on grid points.</p> <p>Attributes:</p> Name Type Description <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> <code>xmin</code> <code>float</code> <p>Minimum value of the grid.</p> <code>xmax</code> <code>float</code> <p>Maximum value of the grid.</p> <code>mass</code> <code>float</code> <p>Mass of the particle.</p> <code>xgrid</code> <code>ndarray</code> <p>Array of grid points in position space.</p> <code>dx</code> <code>float</code> <p>Spacing between grid points.</p> <code>dk</code> <code>float</code> <p>Spacing in momentum space.</p> <code>kgrid</code> <code>ndarray</code> <p>Array of grid points in momentum space.</p> <code>ak2</code> <code>ndarray</code> <p>Kinetic energy array in momentum space.</p> <code>hamk</code> <code>ndarray</code> <p>Kinetic Hamiltonian matrix in position space.</p> <code>potential</code> <code>Optional[ndarray]</code> <p>Potential energy array on the grid.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DVR_grid:\n    \"\"\"Class for Discrete Variable Representation (DVR) grid methods.\n\n    This class handles grid-based representations for systems where the potential is expressed on grid points.\n\n    Attributes:\n        Ngrid (int): Number of grid points.\n        xmin (float): Minimum value of the grid.\n        xmax (float): Maximum value of the grid.\n        mass (float): Mass of the particle.\n        xgrid (np.ndarray): Array of grid points in position space.\n        dx (float): Spacing between grid points.\n        dk (float): Spacing in momentum space.\n        kgrid (np.ndarray): Array of grid points in momentum space.\n        ak2 (np.ndarray): Kinetic energy array in momentum space.\n        hamk (np.ndarray): Kinetic Hamiltonian matrix in position space.\n        potential (Optional[np.ndarray]): Potential energy array on the grid.\n    \"\"\"\n\n    def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n        \"\"\"\n        Initialize the DVR_grid instance.\n\n        Args:\n            xmin (float): Minimum x-value.\n            xmax (float): Maximum x-value.\n            Ngrid (int): Number of grid points.\n            mass (float): Mass of the particle.\n        \"\"\"\n        self.Ngrid: int = Ngrid\n        self.xmin: float = xmin\n        self.xmax: float = xmax\n        self.mass: float = mass\n\n        # Set up the position grid.\n        self.xgrid: np.ndarray = np.array([])\n        self._set_xgrid()\n        self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n        # Set up the momentum grid.\n        self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n        self.kgrid: np.ndarray = np.array([])\n        self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n        self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n        self._set_kinet_ham()\n\n        # Potential energy array (to be set later).\n        self.potential: Optional[np.ndarray] = None\n\n    def _set_xgrid(self) -&gt; None:\n        \"\"\"\n        Set up the position space grid.\n\n        Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n        \"\"\"\n        self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n\n    def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n        \"\"\"\n        Set up the potential energy array on the grid.\n\n        Args:\n            func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n        \"\"\"\n        self.potential = np.zeros_like(self.xgrid)\n        for i in range(self.Ngrid):\n            self.potential[i] = func_pot(self.xgrid[i])\n\n    def _set_kinet_ham(self) -&gt; None:\n        \"\"\"\n        Set up the kinetic Hamiltonian matrix in position space.\n\n        This method computes the momentum grid and the corresponding kinetic energy values,\n        and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n        \"\"\"\n        self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n        self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n        coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n        for i in range(self.Ngrid):\n            if i &lt; self.Ngrid // 2:\n                self.kgrid[i] = i * self.dk\n            else:\n                self.kgrid[i] = -(self.Ngrid - i) * self.dk\n            self.ak2[i] = coef_k * self.kgrid[i]**2\n\n        akx0: np.ndarray = sfft.ifft(self.ak2)\n        self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n        for i in range(self.Ngrid):\n            for j in range(self.Ngrid):\n                if i &lt; j:\n                    self.hamk[i, j] = akx0[i - j].conj()\n                else:\n                    self.hamk[i, j] = akx0[i - j]\n\n    def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get the eigenstates for the potential in x-space.\n\n        Args:\n            Nstate (int): Number of eigenstates to output.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: A tuple containing:\n                - Eigenvalues (np.ndarray) for the first `Nstate` states.\n                - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n        \"\"\"\n        Mata: np.ndarray = self.hamk.copy()\n        for i in range(self.Ngrid):\n            Mata[i, i] += self.potential[i]\n\n        val, arr = LA.eigh(Mata)\n        return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n\n    def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from position space to momentum space.\n\n        Args:\n            psi (np.ndarray): Wavefunction in position space.\n\n        Returns:\n            np.ndarray: Wavefunction in momentum space.\n        \"\"\"\n        return tb.x2k_wave(self.dx, psi)\n\n    def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from momentum space to position space.\n\n        Args:\n            psik (np.ndarray): Wavefunction in momentum space.\n\n        Returns:\n            np.ndarray: Wavefunction in position space.\n        \"\"\"\n        return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.__init__","title":"<code>__init__(xmin, xmax, Ngrid, mass)</code>","text":"<p>Initialize the DVR_grid instance.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum x-value.</p> required <code>xmax</code> <code>float</code> <p>Maximum x-value.</p> required <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> required <code>mass</code> <code>float</code> <p>Mass of the particle.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n    \"\"\"\n    Initialize the DVR_grid instance.\n\n    Args:\n        xmin (float): Minimum x-value.\n        xmax (float): Maximum x-value.\n        Ngrid (int): Number of grid points.\n        mass (float): Mass of the particle.\n    \"\"\"\n    self.Ngrid: int = Ngrid\n    self.xmin: float = xmin\n    self.xmax: float = xmax\n    self.mass: float = mass\n\n    # Set up the position grid.\n    self.xgrid: np.ndarray = np.array([])\n    self._set_xgrid()\n    self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n    # Set up the momentum grid.\n    self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n    self.kgrid: np.ndarray = np.array([])\n    self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n    self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n    self._set_kinet_ham()\n\n    # Potential energy array (to be set later).\n    self.potential: Optional[np.ndarray] = None\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid._set_kinet_ham","title":"<code>_set_kinet_ham()</code>","text":"<p>Set up the kinetic Hamiltonian matrix in position space.</p> <p>This method computes the momentum grid and the corresponding kinetic energy values, and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def _set_kinet_ham(self) -&gt; None:\n    \"\"\"\n    Set up the kinetic Hamiltonian matrix in position space.\n\n    This method computes the momentum grid and the corresponding kinetic energy values,\n    and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n    \"\"\"\n    self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n    self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n    coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n    for i in range(self.Ngrid):\n        if i &lt; self.Ngrid // 2:\n            self.kgrid[i] = i * self.dk\n        else:\n            self.kgrid[i] = -(self.Ngrid - i) * self.dk\n        self.ak2[i] = coef_k * self.kgrid[i]**2\n\n    akx0: np.ndarray = sfft.ifft(self.ak2)\n    self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n    for i in range(self.Ngrid):\n        for j in range(self.Ngrid):\n            if i &lt; j:\n                self.hamk[i, j] = akx0[i - j].conj()\n            else:\n                self.hamk[i, j] = akx0[i - j]\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid._set_xgrid","title":"<code>_set_xgrid()</code>","text":"<p>Set up the position space grid.</p> <p>Initializes the <code>xgrid</code> attribute using a linear space between <code>xmin</code> and <code>xmax</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def _set_xgrid(self) -&gt; None:\n    \"\"\"\n    Set up the position space grid.\n\n    Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n    \"\"\"\n    self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.get_eig_state","title":"<code>get_eig_state(Nstate)</code>","text":"<p>Get the eigenstates for the potential in x-space.</p> <p>Parameters:</p> Name Type Description Default <code>Nstate</code> <code>int</code> <p>Number of eigenstates to output.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing: - Eigenvalues (np.ndarray) for the first <code>Nstate</code> states. - Eigenvectors (np.ndarray) for the first <code>Nstate</code> states, normalized by sqrt(dx).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get the eigenstates for the potential in x-space.\n\n    Args:\n        Nstate (int): Number of eigenstates to output.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - Eigenvalues (np.ndarray) for the first `Nstate` states.\n            - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n    \"\"\"\n    Mata: np.ndarray = self.hamk.copy()\n    for i in range(self.Ngrid):\n        Mata[i, i] += self.potential[i]\n\n    val, arr = LA.eigh(Mata)\n    return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.k2x_wave","title":"<code>k2x_wave(psik)</code>","text":"<p>Transform the wavefunction from momentum space to position space.</p> <p>Parameters:</p> Name Type Description Default <code>psik</code> <code>ndarray</code> <p>Wavefunction in momentum space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in position space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from momentum space to position space.\n\n    Args:\n        psik (np.ndarray): Wavefunction in momentum space.\n\n    Returns:\n        np.ndarray: Wavefunction in position space.\n    \"\"\"\n    return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.set_potential","title":"<code>set_potential(func_pot)</code>","text":"<p>Set up the potential energy array on the grid.</p> <p>Parameters:</p> Name Type Description Default <code>func_pot</code> <code>Callable[[float], float]</code> <p>Function that returns the potential value at a given x.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n    \"\"\"\n    Set up the potential energy array on the grid.\n\n    Args:\n        func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n    \"\"\"\n    self.potential = np.zeros_like(self.xgrid)\n    for i in range(self.Ngrid):\n        self.potential[i] = func_pot(self.xgrid[i])\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.x2k_wave","title":"<code>x2k_wave(psi)</code>","text":"<p>Transform the wavefunction from position space to momentum space.</p> <p>Parameters:</p> Name Type Description Default <code>psi</code> <code>ndarray</code> <p>Wavefunction in position space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in momentum space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from position space to momentum space.\n\n    Args:\n        psi (np.ndarray): Wavefunction in position space.\n\n    Returns:\n        np.ndarray: Wavefunction in momentum space.\n    \"\"\"\n    return tb.x2k_wave(self.dx, psi)\n</code></pre>"},{"location":"qflux/tests/","title":"Testing Scientific Code","text":"<p>This guide covers principles and practices for testing scientific code, with a focus on computational chemistry, machine learning, and numerical computing.</p>"},{"location":"qflux/tests/#why-test-scientific-code","title":"Why Test Scientific Code?","text":"<ol> <li> <p>Correctness Verification</p> <ul> <li>Scientific code often implements complex mathematical formulas</li> <li>Small errors can propagate and lead to incorrect results</li> <li>Tests help verify mathematical and physical principles</li> </ul> </li> <li> <p>Reproducibility</p> <ul> <li>Tests document expected behavior</li> <li>Help ensure consistent results across different environments</li> <li>Critical for scientific reproducibility</li> </ul> </li> <li> <p>Code Evolution</p> <ul> <li>Safe refactoring of performance-critical code</li> <li>Confidence when updating dependencies</li> <li>Protection against regression</li> </ul> </li> </ol>"},{"location":"qflux/tests/#what-to-test","title":"What to Test","text":""},{"location":"qflux/tests/#1-physical-invariants","title":"1. Physical Invariants","text":"<pre><code>def test_rotation_preserves_distances():\n    \"\"\"Test that rotation preserves interatomic distances.\"\"\"\n    dist_before = molecule.calculate_distance_matrix()\n    rotated = rotate_molecule(molecule, angle=np.pi/3)\n    dist_after = rotated.calculate_distance_matrix()\n    assert_array_almost_equal(dist_before, dist_after)\n</code></pre>"},{"location":"qflux/tests/#2-mathematical-properties","title":"2. Mathematical Properties","text":"<ul> <li>Symmetry relations</li> <li>Conservation laws</li> <li>Matrix properties (hermiticity, unitarity)</li> <li>Boundary conditions</li> </ul>"},{"location":"qflux/tests/#3-edge-cases","title":"3. Edge Cases","text":"<ul> <li>Zero values</li> <li>Extreme values</li> <li>Singular matrices</li> <li>Empty/single-element inputs</li> </ul>"},{"location":"qflux/tests/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Invalid inputs</li> <li>Numerical instabilities</li> <li>Resource limitations</li> <li>Type mismatches</li> </ul>"},{"location":"qflux/tests/#testing-ml-code","title":"Testing ML Code","text":""},{"location":"qflux/tests/#1-data-pipeline","title":"1. Data Pipeline","text":"<ul> <li>Data loading and preprocessing</li> <li>Augmentation correctness</li> <li>Batch generation</li> <li>Edge cases in data</li> </ul> <pre><code>def test_data_normalization():\n    \"\"\"Test that normalization preserves relative ordering.\"\"\"\n    x_raw = np.random.randn(100, 10)\n    x_norm = normalize_features(x_raw)\n\n    # Check bounds\n    assert np.all((-1 &lt;= x_norm) &amp; (x_norm &lt;= 1))\n\n    # Check relative ordering is preserved\n    for i in range(10):\n        correlation = np.corrcoef(x_raw[:, i], x_norm[:, i])[0, 1]\n        assert abs(correlation) &gt; 0.99\n</code></pre>"},{"location":"qflux/tests/#2-model-components","title":"2. Model Components","text":"<ul> <li>Layer operations</li> <li>Activation functions</li> <li>Loss calculations</li> <li>Gradient computations</li> </ul> <pre><code>def test_softmax_properties():\n    \"\"\"Test mathematical properties of softmax.\"\"\"\n    logits = np.random.randn(10, 5)\n    probs = softmax(logits)\n\n    # Sum to 1\n    assert_array_almost_equal(np.sum(probs, axis=1), 1.0)\n\n    # Range [0, 1]\n    assert np.all((0 &lt;= probs) &amp; (probs &lt;= 1))\n</code></pre>"},{"location":"qflux/tests/#3-training-process","title":"3. Training Process","text":"<ul> <li>Learning rate scheduling</li> <li>Weight updates</li> <li>Convergence on simple cases</li> <li>Reproducibility with fixed seeds</li> </ul>"},{"location":"qflux/tests/#4-model-behavior","title":"4. Model Behavior","text":"<ul> <li>Invariance properties</li> <li>Expected behavior on synthetic data</li> <li>Performance bounds</li> <li>Resource usage</li> </ul>"},{"location":"qflux/tests/#testing-numerical-code","title":"Testing Numerical Code","text":""},{"location":"qflux/tests/#1-numerical-stability","title":"1. Numerical Stability","text":"<pre><code>def test_numerical_stability():\n    \"\"\"Test stability of operations on poorly conditioned matrices.\"\"\"\n    # Create ill-conditioned matrix\n    A = create_ill_conditioned_matrix(condition_number=1e10)\n    x = np.random.randn(A.shape[1])\n\n    # Test different solution methods\n    x1 = solve_direct(A, b)\n    x2 = solve_iterative(A, b)\n\n    # Check both methods give similar results\n    assert_array_almost_equal(x1, x2, decimal=5)\n</code></pre>"},{"location":"qflux/tests/#2-precision-and-tolerance","title":"2. Precision and Tolerance","text":"<ul> <li>Use appropriate tolerances for floating-point comparisons</li> <li>Consider platform differences</li> <li>Test with different precisions</li> <li>Handle underflow/overflow</li> </ul>"},{"location":"qflux/tests/#testing-strategies","title":"Testing Strategies","text":""},{"location":"qflux/tests/#1-property-based-testing","title":"1. Property-Based Testing","text":"<pre><code>@given(st.lists(st.floats(min_value=-1e3, max_value=1e3), min_size=1))\ndef test_normalization_properties(x):\n    \"\"\"Test normalization for arbitrary inputs.\"\"\"\n    normalized = normalize_vector(x)\n    assert abs(np.linalg.norm(normalized) - 1.0) &lt; 1e-10\n</code></pre>"},{"location":"qflux/tests/#2-parameterized-tests","title":"2. Parameterized Tests","text":"<pre><code>@pytest.mark.parametrize(\"angle\", [0, np.pi/2, np.pi, 3*np.pi/2])\ndef test_rotation_special_angles(angle):\n    \"\"\"Test rotation for special angles.\"\"\"\n</code></pre>"},{"location":"qflux/tests/#3-reference-solutions","title":"3. Reference Solutions","text":"<ul> <li>Compare against known analytical solutions</li> <li>Test against established software</li> <li>Verify with different algorithms</li> </ul>"},{"location":"qflux/tests/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Test Organization</p> <ul> <li>Group related tests in classes</li> <li>Use fixtures for common setups</li> <li>Separate unit and integration tests</li> </ul> </li> <li> <p>Performance Considerations</p> <ul> <li>Keep unit tests fast</li> <li>Use smaller datasets for tests</li> <li>Mark slow tests appropriately</li> </ul> </li> <li> <p>Documentation</p> <ul> <li>Document test assumptions</li> <li>Explain physical/mathematical meaning</li> <li>Reference equations or papers</li> </ul> </li> <li> <p>Continuous Integration</p> <ul> <li>Run tests on multiple platforms</li> <li>Test with different dependency versions</li> <li>Include performance benchmarks</li> </ul> </li> </ol>"},{"location":"qflux/tests/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Floating-Point Comparisons</li> </ol> <pre><code># Bad\nassert x == 1.0\n\n# Good\nassert_almost_equal(x, 1.0, decimal=6)\n</code></pre> <ol> <li>Random Numbers</li> </ol> <pre><code># Bad\nx = np.random.randn(100)\n\n# Good\nrng = np.random.default_rng(seed=42)\nx = rng.standard_normal(100)\n</code></pre> <ol> <li>Resource Management</li> </ol> <pre><code># Bad\ndef test_large_computation():\n    result = compute_with_large_matrix(1000000)\n\n# Good\n@pytest.mark.large\ndef test_large_computation():\n    result = compute_with_large_matrix(1000)\n</code></pre>"},{"location":"qflux/tests/#when-to-skip-testing","title":"When to Skip Testing","text":"<p>While testing is crucial, some cases might not require tests:</p> <ol> <li> <p>Visualization Code</p> <ul> <li>Plot formatting</li> <li>Color schemes</li> <li>Interactive features</li> </ul> </li> <li> <p>Configuration</p> <ul> <li>Static configuration files</li> <li>Environment settings</li> <li>Documentation</li> </ul> </li> <li> <p>Prototype Code</p> <ul> <li>Exploratory analysis</li> <li>One-off scripts</li> <li>Temporary debugging code</li> </ul> </li> </ol>"},{"location":"qflux/tests/#conclusion","title":"Conclusion","text":"<p>Testing scientific code requires a balance between:</p> <ul> <li>Mathematical correctness</li> <li>Numerical stability</li> <li>Performance</li> <li>Maintainability</li> </ul> <p>Focus on testing the critical aspects that ensure scientific validity and reproducibility of your results.</p>"},{"location":"qflux/variational_methods/","title":"Variational Methods  Module","text":""},{"location":"qflux/variational_methods/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>variational_methods</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/variational_methods/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/variational_methods/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/variational_methods/#source-code","title":"Source Code","text":""},{"location":"qflux/variational_methods/#qflux.variational_methods","title":"<code>qflux.variational_methods</code>","text":""},{"location":"qflux/workflows/","title":"GitHub Workflows","text":"<p>This project uses several GitHub Actions workflows to automate various development and release processes. Here's a detailed overview of each workflow:</p>"},{"location":"qflux/workflows/#code-quality-qualityyml","title":"Code Quality (<code>quality.yml</code>)","text":"<p>This workflow ensures code quality standards are maintained:</p> <ul> <li>Trigger: Runs on every push and pull request</li> <li>Actions:</li> <li>Runs Ruff for linting and formatting checks</li> <li>Runs MyPy for static type checking</li> <li>Environment: Uses Python 3.12 and uv for dependency management</li> </ul>"},{"location":"qflux/workflows/#tests-testsyml","title":"Tests (<code>tests.yml</code>)","text":"<p>Handles automated testing of the codebase:</p> <ul> <li>Trigger: Runs on every push and pull request</li> <li>Actions:</li> <li>Sets up Python 3.12 environment</li> <li>Installs project dependencies using uv</li> <li>Runs pytest with verbose output</li> <li>Features:</li> <li>Caches dependencies for faster workflow execution</li> <li>Uses virtual environment for isolated testing</li> </ul>"},{"location":"qflux/workflows/#release-management","title":"Release Management","text":""},{"location":"qflux/workflows/#release-drafter-release-drafteryml","title":"Release Drafter (<code>release-drafter.yml</code>)","text":"<p>Automates the creation of release notes and manages PR labeling:</p> <ul> <li>Triggers:</li> <li>On push to main branch</li> <li>On pull request events (opened, reopened, synchronize)</li> <li>Manual trigger (workflow_dispatch)</li> <li>Actions:</li> <li>Automatically assigns labels to PRs based on commit message prefixes</li> <li>Drafts release notes based on PR labels</li> <li>Commit Prefix to Label Mapping:</li> <li><code>BREAKING CHANGE</code>, <code>BREAKING</code>, <code>MAJOR</code> \u2192 breaking-change</li> <li><code>feat</code>, <code>FEAT</code>, <code>Feature</code> \u2192 new-feature</li> <li><code>fix</code>, <code>FIX</code>, <code>Fixed</code> \u2192 bugfix</li> <li><code>enhance</code>, <code>ENHANCE</code>, <code>improvement</code> \u2192 enhancement</li> <li><code>refactor</code>, <code>REFACTOR</code> \u2192 refactor</li> <li><code>perf</code>, <code>PERFORMANCE</code> \u2192 performance</li> <li><code>docs</code>, <code>DOC</code> \u2192 documentation</li> <li><code>tests</code>, <code>TESTS</code> \u2192 tests</li> <li>Categories:</li> <li>\ud83d\udea8 Breaking changes</li> <li>\u2728 New features</li> <li>\ud83d\udc1b Bug fixes</li> <li>\ud83d\ude80 Enhancements</li> <li>\ud83e\uddf0 Maintenance</li> <li>\ud83d\udcda Documentation</li> <li>\u2b06\ufe0f Dependency updates</li> <li>Version Resolution:</li> <li>Major: breaking changes</li> <li>Minor: new features, enhancements</li> <li>Patch: bugfixes, default updates</li> </ul>"},{"location":"qflux/workflows/#publish-release-publish-releaseyml","title":"Publish Release (<code>publish-release.yml</code>)","text":"<p>Handles the publication of releases:</p> <ul> <li>Trigger: Runs when a release is published</li> <li>Actions:</li> <li>Builds Python package using uv</li> <li>Uploads built artifacts to the GitHub release</li> <li>Environment: Uses Python 3.12 and uv for building</li> </ul>"},{"location":"qflux/workflows/#version-management","title":"Version Management","text":""},{"location":"qflux/workflows/#version-bump-version-bumpyml","title":"Version Bump (<code>version-bump.yml</code>)","text":"<p>Handles automated version bumping of the project.</p>"},{"location":"qflux/workflows/#update-majorminor-tags-update-major-minor-tagsyml","title":"Update Major/Minor Tags (<code>update-major-minor-tags.yml</code>)","text":"<p>Updates major and minor version tags when new releases are published.</p>"},{"location":"qflux/workflows/#workflow-dependencies","title":"Workflow Dependencies","text":"<p>All workflows use:</p> <ul> <li><code>uv</code> for Python package management</li> <li>GitHub Actions cache for optimizing workflow execution</li> <li>Ubuntu latest as the running environment</li> </ul>"},{"location":"qflux/workflows/#best-practices","title":"Best Practices","text":"<p>When contributing to this project:</p> <ol> <li>Ensure your commits are properly labeled to be categorized in release notes</li> <li>All tests must pass and code quality checks must succeed</li> <li>New features should include appropriate tests</li> <li>Breaking changes must be clearly marked with the \"breaking-change\" label</li> </ol>"}]}