{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the QFlux Documentation","text":"<p>This is a Python package containing various protocols for performing quantum dynamics simulations with quantum devices. Each submodule contains object-oriented implementations for these protocols as demonstrated in our publication, as well as comprehensive tutorial notebooks designed to help users understand, implement and build upon various simulation techniques for studying quantum dynamics using quantum computer frameworks. Each tutorial is provided in Python, using Jupyter Notebooks to offer detailed explanations in both markdown and code comments.</p>"},{"location":"#installation","title":"Installation","text":"<p>This project uses <code>uv</code> for fast and reliable Python package management. To set up your development environment:</p> <pre><code># Create and activate a virtual environment\nuv venv\nsource .venv/bin/activate\n\n# Install the package and all development dependencies\nuv pip install -e \".[dev]\"\n# Initiate pre-commit checks\npre-commit install\n</code></pre> <p>This will install all necessary dependencies, including development tools like pre-commit hooks, testing frameworks, and documentation generators.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>.\n\u251c\u2500\u2500 data/           # Data files and resources\n\u251c\u2500\u2500 docs/           # Documentation files (MkDocs)\n\u251c\u2500\u2500 scripts/        # Utility and automation scripts\n\u251c\u2500\u2500 src/            # Source code\n\u2502   \u2514\u2500\u2500 qflux/\n\u251c\u2500\u2500 tests/          # Test files\n\u251c\u2500\u2500 .github/        # GitHub Actions workflows\n\u251c\u2500\u2500 mkdocs.yml      # MkDocs configuration\n\u251c\u2500\u2500 pyproject.toml  # Project dependencies and settings\n\u2514\u2500\u2500 .pre-commit-config.yaml  # Pre-commit hooks configuration\n</code></pre>"},{"location":"#development-setup","title":"Development Setup","text":""},{"location":"#documentation","title":"Documentation","text":"<p>This project uses MkDocs with the Material theme for documentation. To work with the documentation locally:</p> <ol> <li>Make sure you have all development dependencies installed</li> <li>Run the documentation server:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <ol> <li>Open your browser and navigate to <code>http://127.0.0.1:8000</code></li> </ol> <p>The documentation will automatically reload when you make changes to the markdown files.</p>"},{"location":"#code-quality-tools","title":"Code Quality Tools","text":"<p>We use pre-commit hooks to ensure code quality and consistency. The following tools are configured in <code>.pre-commit-config.yaml</code>:</p> <ul> <li>Ruff: A fast Python linter and formatter</li> <li>Runs linting checks with auto-fix capability</li> <li>Handles code formatting</li> </ul> <p>After installing the development dependencies (as described in the Installation section), enable the pre-commit hooks by running:</p> <pre><code>pre-commit install\n</code></pre> <p>Now the hooks will run automatically on every commit, ensuring code quality and consistency.</p>"},{"location":"#managing-dependencies","title":"Managing Dependencies","text":"<p>This project uses <code>uv</code> for fast and reliable dependency management. Here's how to manage your dependencies:</p>"},{"location":"#adding-new-dependencies","title":"Adding New Dependencies","text":"<p>To add a new package dependency:</p> <pre><code>uv add package_name\n# Add a development dependency\nuv add --dev package_name\n</code></pre> <p>This will:</p> <ol> <li>Install the package in your virtual environment</li> <li>Update your <code>pyproject.toml</code> with the new dependency</li> <li>Update the <code>uv.lock</code> file with exact versions</li> </ol>"},{"location":"#synchronizing-dependencies","title":"Synchronizing Dependencies","text":"<p>If you pull changes that include new dependencies or switch branches, synchronize your environment:</p> <pre><code>uv sync\n</code></pre> <p>This ensures your virtual environment exactly matches the dependencies specified in the lock file, removing any packages you don't need and installing any that are missing.</p>"},{"location":"#writing-documentation","title":"Writing Documentation","text":"<p>This project follows a structured approach to documentation. Each module should have its own markdown file in the <code>docs/batistatemplate/</code> directory. Documentation files might include:</p> <ol> <li>Overview: A brief description of the module's purpose and key features</li> <li>Concepts: Explanation of important concepts and design decisions</li> <li>Examples: Code examples showing common usage patterns</li> <li>Source Code: Auto-generated documentation from source code annotations</li> </ol>"},{"location":"logging/","title":"Logging Best Practices","text":"<p>This guide explains how to effectively use Python's logging module in our codebase, whether you're writing modules, running scripts from CLI, or working in Jupyter notebooks.</p>"},{"location":"logging/#environment-variables","title":"Environment Variables","text":"<p>The application's log level can be controlled using the <code>QFLUX_LOG_LEVEL</code> environment variable:</p> <pre><code># Set log level for the current session\nexport QFLUX_LOG_LEVEL=DEBUG\npython your_script.py\n\n# Or set it for a single command\nQFLUX_LOG_LEVEL=DEBUG python your_script.py\n</code></pre> <p>Valid log levels are:</p> <ul> <li><code>DEBUG</code>: Most verbose, detailed debugging information</li> <li><code>INFO</code>: General operational information (default)</li> <li><code>WARNING</code>: Unexpected situations that aren't errors</li> <li><code>ERROR</code>: Serious problems that need attention</li> <li><code>CRITICAL</code>: Critical issues that may cause program failure</li> </ul>"},{"location":"logging/#module-development","title":"Module Development","text":"<p>When writing a module, follow these guidelines:</p> <pre><code>from batistatemplate.utils.logging_config import logger\n\ndef my_function():\n    # Use appropriate log levels\n    logger.debug(\"Detailed information for debugging\")\n    logger.info(\"General information about progress\")\n    logger.warning(\"Something unexpected but not error\")\n    logger.error(\"A more serious problem\")\n    logger.critical(\"Program may not be able to continue\")\n</code></pre> <p>Key points:</p> <ul> <li>Don't configure the logger in your modules</li> <li>Always use <code>from batistatemplate.utils.logging_config import logger</code></li> <li>Choose appropriate log levels</li> <li>Don't use print statements for debugging</li> <li>Don't add parameters like <code>verbose</code> to your functions</li> </ul>"},{"location":"logging/#jupyter-notebook-usage","title":"Jupyter Notebook Usage","text":"<p>For Jupyter notebooks, put this in your first cell:</p> <pre><code>from batistatemplate.utils.logging_config import logger\n\nlogger.setLevel(logging.DEBUG)  # To see debug messages\nlogger.setLevel(logging.INFO)   # Back to info only\n</code></pre>"},{"location":"logging/#log-levels-guide","title":"Log Levels Guide","text":"<p>Choose the appropriate level based on the message importance:</p> <ul> <li>DEBUG: Detailed information for diagnosing problems</li> </ul> <pre><code>logger.debug(f\"Processing data frame with shape {df.shape}\")\n</code></pre> <ul> <li>INFO: Confirmation that things are working as expected</li> </ul> <pre><code>logger.info(\"Model training started\")\n</code></pre> <ul> <li>WARNING: Indication that something unexpected happened</li> </ul> <pre><code>logger.warning(\"Using fallback parameter value\")\n</code></pre> <ul> <li>ERROR: More serious problem that prevented function from working</li> </ul> <pre><code>logger.error(\"Failed to load model weights\")\n</code></pre> <ul> <li>CRITICAL: Program may not be able to continue</li> </ul> <pre><code>logger.critical(\"Out of memory - cannot continue processing\")\n</code></pre>"},{"location":"logging/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Configuring Loggers in Modules: Only configure logging in your entry points (main scripts, notebooks)</p> </li> <li> <p>Using Print Statements: Avoid print statements for debugging; use logger.debug instead</p> </li> <li> <p>Hard-coding Log Levels: Don't set log levels in your modules; let the application control them</p> </li> <li> <p>Creating Multiple Handlers: Clear existing handlers in notebooks to avoid duplicate logs</p> </li> <li> <p>Using f-strings for Debug Messages: For expensive operations, check level first:</p> </li> </ol> <pre><code># Bad (string formatting happens regardless of level)\nlogger.debug(f\"Expensive operation result: {expensive_operation()}\")\n\n# Good (string formatting only happens if needed)\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(f\"Expensive operation result: {expensive_operation()}\")\n</code></pre>"},{"location":"qflux/closed_systems/","title":"Closed Systems Module","text":""},{"location":"qflux/closed_systems/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>closed_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/closed_systems/#examples-and-introductory-concepts","title":"Examples and Introductory Concepts","text":"<p>Before we look at doing Quantum Dynamics on a quantum computer, we'll start out by looking at some ways that we can do quantum dynamics on a classical computer! This is an important step as it will familiarize you with the general ingredients of a quantum dynamics simulation and will also provide us with a means of validating the results obtained from a quantum computer.</p>"},{"location":"qflux/closed_systems/#your-first-simulation-the-quantum-harmonic-oscillator","title":"Your first simulation: The Quantum Harmonic Oscillator","text":""},{"location":"qflux/closed_systems/#propagation-in-the-ladder-basis","title":"Propagation in the Ladder Basis","text":"<p>We begin by showing a simple example of how to compute dynamics of an initial state using QuTiP's mesolve() function. When we run dynamics, we must do the following:</p> <ol> <li> <p>Define the initial state \\(\\left| \\alpha \\right\\rangle\\). In this example, our initial state is defined as a coherent state with amplitude \\(\\alpha = x_{0} + i p_{0}\\), which can be expressed in the Fock Basis as:</p> \\[ \\left| \\alpha \\right\\rangle = \\frac{\\alpha^{n}}{\\sqrt{n!}} e^{-\\frac{1}{2}\\left| \\alpha \\right|^{2}} \\left| n \\right\\rangle \\] </li> <li> <p>Define the Hamiltonian \\(H\\). In this example, our Hamiltonian is the familiar quantum harmonic oscillator Hamiltonian, defined in terms of creation and annihilation operators as:</p> \\[ H =  \\hbar \\omega \\left( \\hat{a}^{\\dagger} \\hat{a} + \\frac{1}{2} \\right) \\] </li> <li> <p>Define the propagation time step \\(t\\) and the number of time steps \\(n\\) for which to compute the wavefunction.</p> </li> <li> <p>Compute the time-evolved wavefunction at each step as:</p> \\[ \\left| \\alpha (t_{i+1}) \\right\\rangle = e^{-\\frac{i}{\\hbar} H t} \\left| \\alpha(t_{i}) \\right\\rangle \\] </li> </ol> <p>All this can be done using QFlux as follows: </p> <pre><code># Import the package and relevant modules\nimport qflux\nfrom qflux.closed_systems import DynamicsCS\n# Instantiate our Closed-Systems Dynamics Class\nqho_dyn_obj = DynamicsCS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n# Define our coordinate x and p operators\nqho_dyn_obj.set_coordinate_operators()\n# Initialize the ladder operators\nqho_dyn_obj.initialize_operators()\n# Define the default initial state (note that custom initialization is also supported)\nqho_dyn_obj.set_initial_state()\n# Define some parameters for the time evolution\ntotal_time = 20.0\nN_steps = 400\nqho_dyn_obj.set_propagation_time(total_time, N_steps)\n# Set the Potential/Hamiltonian for our object, in this case using the pre-defined 'harmonic' oscillator potential\nqho_dyn_obj.set_hamiltonian(potential_type='harmonic')\n# Propagate using the QuTiP sesolve method\nqho_dyn_obj.propagate_qt()\n</code></pre> <p>We can validate our result by computing and plotting the expectation values of \\(x\\) and \\(p\\) as a function of time and comparing to the analytic results: </p> <pre><code>import qutip as qt\nimport numpy as np\nimport matplotlib.pyplot as plt \n\n# Compute expectation values &lt;x&gt; and &lt;p&gt;\nexp_x_qt = qt.expect(qho_dyn_obj.x_op, qho_dyn_obj.dynamics_results_op.states)\nexp_p_qt = qt.expect(qho_dyn_obj.p_op, qho_dyn_obj.dynamics_results_op.states)\n\nexp_x_ana = [ qho_dyn_obj.xo*np.cos(qho_dyn_obj.omega*t) + (qho_dyn_obj.po/qho_dyn_obj.mass/qho_dyn_obj.omega)*np.sin(qho_dyn_obj.omega*t) for t in qho_dyn_obj.tlist]\nexp_p_ana = [ qho_dyn_obj.po*np.cos(qho_dyn_obj.omega*t) -qho_dyn_obj.xo*qho_dyn_obj.omega*qho_dyn_obj.mass*np.sin(qho_dyn_obj.omega*t)  for t in qho_dyn_obj.tlist]\n\n# Plot the final result\nplt.figure(figsize=(9, 6.5))\nplt.plot(qho_dyn_obj.tlist, exp_x_qt, label=r'$\\left\\langle x \\right\\rangle$ (QuTiP)', color='dodgerblue')\nplt.plot(qho_dyn_obj.tlist, exp_x_ana, label=r'$\\left\\langle x \\right\\rangle$ (Analytic)',\n         lw=0, marker='x', markevery=10, color='dodgerblue', ms=8)\nplt.plot(qho_dyn_obj.tlist, exp_p_qt, label=r'$\\left\\langle p \\right\\rangle$ (QuTiP)', color='crimson')\nplt.plot(qho_dyn_obj.tlist, exp_p_ana, label=r'$\\left\\langle p \\right\\rangle$ (Analytic)',\n         lw=0, marker='x', markevery=10, color='crimson', ms=8)\n# plt.plot(qho_dyn_obj.tlist, exp_p_grid, color='orange')\n\nplt.ylim(-1.55, 1.55)\n\nplt.legend(ncols=2, loc='upper center')\nplt.hlines([-1, 0, 1], min(qho_dyn_obj.tlist), max(qho_dyn_obj.tlist), ls='--', lw=0.85, color='tab:grey', zorder=2)\n</code></pre> <p></p> <p>Hopefully the agreement in this plot convinces you that we're doing something correct! </p>"},{"location":"qflux/closed_systems/#propagation-in-the-coordinate-basis","title":"Propagation in the Coordinate Basis","text":"<p>We can also propagate a wavefunction in a coordinate-grid representation using the so-called Split-Operator Fourier Transform (SOFT) method. </p> <p>\\(\\renewcommand{\\intertext}[1]{\\\\\\ \\textrm{#1}\\\\}\\)</p> <p>Here, we compute the time-evolution of a wavepacket defined in the position basis (\\(\\psi(x)\\)) according to the Split-Operator Fourier Transform (SOFT) method. This differs slightly from the approach utilized in the last section in the following ways:</p> <ul> <li>As mentioned above, we will describe the wavefunction in terms of the position. To do this, we must define a closed range of positions \\(x\\) and momenta \\(p\\) and discretize over some finite number of points (analagous to the finite number of Fock states considered above).</li> <li>We will compute the time evolution as:</li> </ul> \\[ \\left| \\psi (t) \\right\\rangle =  e^{- \\frac{i}{\\hbar} {H} t} \\left| \\psi(0) \\right\\rangle \\] <p>Writing \\(H\\) in terms of Kinetic and Potential energy \\(H = T + V\\):</p> \\[\\begin{align*}         \\left| \\psi (t) \\right\\rangle &amp;\\approx \\lim\\limits_{N\\to\\infty} \\left[e^{\\frac{-ip^2t}{2m\\hbar N}}\\ e^{\\frac{-i{V}({x})t}{\\hbar N}}\\right]^N \\space |\\psi(0)\\rangle \\\\                                   &amp;\\approx\\lim\\limits_{N\\to\\infty} \\left[e^{\\frac{-i{V}({x})t}{2\\hbar N}}\\space e^{\\frac{-ip^2t}{2m\\hbar N}}\\space e^{\\frac{-i{V}({x})t}{2\\hbar N}}\\right]^N \\space |\\psi(0)\\rangle     \\intertext{Inserting closure and writing in the plane-wave basis: }      \\left| \\psi (x, t) \\right\\rangle &amp;= \\int d x_0 \\space \\langle x_t | e^{\\frac{-i\u0124t}{\\hbar}} | x_0 \\rangle \\space \\langle x_0 | \\psi(0) \\rangle \\end{align*}\\] <p>Propagation for a single timestep is then:</p> \\[\\psi(x,\\frac{t_{i+1}}{N}) = \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} e^{\\frac{-iV(x)t}{2\\hbar N}} }^\\textrm{P.E. Propagator} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} { \\int \\frac{dp}{\\sqrt{2\\pi\\hbar}}  \\   e^{\\frac{-ipx}{\\hbar}}} }^\\textrm{Inverse Fourier Transform} \\ \\cdot \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} \\ e^{\\frac{-ip^2t}{2m\\hbar N}}}^\\textrm{K.E. Propagator} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}} {\\int \\frac{dx}{\\sqrt{2\\pi\\hbar}} \\  e^{\\frac{ipx}{\\hbar}} }}^\\textrm{Fourier Transform} \\ \\cdot \\ \\overbrace{\\vphantom{\\int \\frac{dp}{\\sqrt{2\\hbar}} e^{\\frac{-iV(x)p^{2}}{2 \\hbar N}}}\\ e^{\\frac{-iV(x)t}{2\\hbar N}} }^\\textrm{P.E. Propagator} \\ \\cdot \\ \\psi(x,t_{i})\\] <p>The Fourier and inverse Fourier transforms are used to convert between the position and momentum basis. To translate the formula above, the algorithm will consist of 5 steps per iteration:</p> <ol> <li>Apply a half step of the potential energy propagator to the initial state.</li> <li>Fourier transform into the momentum basis.</li> <li>Apply a full step of the kinetic energy propagator on the momentum basis.</li> <li>Inverse Fourier transform back into the coordinate basis.</li> <li>Apply the second half step of the potential energy propagator.</li> </ol> <p>This is can be done in QFlux with the following code:</p> <pre><code># Instantiate our Closed-Systems Dynamics Class\nqho_dyn_obj = QFlux_CS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)\n# Define our coordinate x and p operators\nqho_dyn_obj.set_coordinate_operators()\n# Initialize the ladder operators\nqho_dyn_obj.initialize_operators()\n# Define the default initial state (note that custom initialization is also supported)\nqho_dyn_obj.set_initial_state()\n# Define some parameters for the time evolution\ntotal_time = 20.0\nN_steps = 400\nqho_dyn_obj.set_propagation_time(total_time, N_steps)\n# Set the Potential/Hamiltonian for our object, in this case using the pre-defined 'harmonic' oscillator potential\nqho_dyn_obj.set_hamiltonian(potential_type='harmonic')\n# Propagate using the QuTiP sesolve method\nqho_dyn_obj.propagate_qt()\n# Propagate with SOFT and QuTiP\nqho_dyn_obj.propagate_SOFT()\n</code></pre>"},{"location":"qflux/closed_systems/#anatomy-of-a-closed-system-quantum-dynamics-simulation","title":"Anatomy of a Closed System Quantum Dynamics Simulation","text":"<p>To run a dynamics simulation, we need to define some key quantities. This section will walk you through the process of defining these things within <code>qflux</code>.</p> <p>As a reminder, the task at hand is compute the time evolution of a wavefunction according to the Schrodinger equation: </p> \\[ \\left| \\psi (t) \\right\\rangle = e^{- \\frac{i}{\\hbar} H t} \\left| \\psi_{0} \\right\\rangle \\] <p>To do this, we must: </p> <ul> <li>Define the initial state \\(\\psi_{0}\\). </li> <li>Define the Hamiltonian describing the system of interest.</li> <li>Define a propgation time-step \\(t\\) and the number of time steps \\(n\\) for which we want to compute the evolved wavefunction. </li> </ul> <p>We will now look at how each of these steps can be done with qflux. </p>"},{"location":"qflux/closed_systems/#definition-of-the-initial-state","title":"Definition of the Initial State","text":"<p>The initial state is our wavefunction \\(\\psi_{0}\\). In order to define this abstract object on a computer, we must define a finite space in which it exists. The number of discrete points in this space is controlled by the <code>n_basis</code> parameter that is passed to the <code>Dynamics_CS</code> class upon instantiation. Note that if you do not define this argument, the default value of 128 is used. Given 128 grid points, we can begin defining operators. To compute the dynamics in the so-called \"Fock basis\", we define the ladder operators \\(\\hat{a}\\), \\(\\hat{x}\\), and \\(\\hat{p}\\). This is done by calling the <code>.intialize_operator()</code> method. To compute the dynamics in the position/coordinate basis, we must define a range of position-values that define the x-grid of our space. This can be done with the <code>.set_coordinate_operators(x_min=-7., x_max=7)</code> method, which will define an array of <code>n_basis</code> points, ranging from <code>x_min</code> to <code>x_max</code>. Now that we've defined the space in which our wavefunction can exist, we can finally define the wavefunction. </p> <p>When instantiating a dynamics object with the <code>Dynamics_CS</code> class, there are some other important arguments that are taken into account: </p> <ul> <li><code>xo</code>: The initial displacement in the position-coordinate. </li> <li><code>po</code>: The initial displacement in the momentum-coordinate. </li> <li><code>mass</code>: The mass of the particle/system of interest.</li> </ul> <p>Note that these should all be defined in atomic units. </p> <p>To define the initial state in our default way, you can simply use the <code>.set_initial_state()</code> method. This takes the optional argument of <code>wfn_omega</code> defining the frequency/width of the intiial state, which takes the default value of 1.0 au. The default initial state in the coordinate basis is defined as a Gaussian coherent state: </p> \\[ \\psi_{0} = \\left( \\frac{m \\omega}{\\pi \\hbar} \\right)^{1/4} e^{- \\frac{m \\omega}{2 \\hbar} \\left( x - x_{0} \\right)^{2} + \\frac{i}{\\hbar} p_{0} x} \\] <p>The default initial state in the ladder/Fock basis is defined as the coherent state with amplitude \\(\\alpha = (x_{0} + i p_{0})/ \\sqrt{2}\\), defined in the Fock basis as: </p> \\[ \\left| \\alpha \\right\\rangle = \\sum_{n=0}^{n_{basis}} \\frac{\\alpha^{n}}{\\sqrt{n!}} e^{- \\frac{1}{2} \\left| \\alpha \\right|^{2} \\left| n \\right\\rangle \\] <p>where \\(n\\) is a state in the Fock basis. </p> <p>Note that <code>qflux</code> also provides functionality for custom state initialization, in which a user-defined function can be provided. </p> <p>Custom initialization in the coordinate basis is done with the <code>.custom_grid_state_initialization()</code> method. This can be used if you wish to initialize with a different state. To exemplify the usage of this functionality, we can define some function that takes arguments necessary to define a state: </p> <pre><code>import numpy as np\n\ndef custom_gaussian(xvals, xo, po, omega, mass, hbar):\n    normalization_factor = (mass * omega / (np.pi * hbar))**(0.25)\n    exp_func = np.exp( - mass * omega / (2 * hbar) * (xvals - xo)**2 + 1j/hbar * po * xvals)\n    return(normalization_factor * exp_func)\n</code></pre> <p>Then, we can set-up a dynamics object that is ready to initialize a state: </p> <pre><code>HO_dyn_obj = Dynamics_CS(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=0.2)\nHO_dyn_obj.set_coordinate_operators()\nHO_dyn_obj.initialize_operators()\n</code></pre> <p>And define some arguments to provide to the function: </p> <pre><code>func_args = {'xvals': HO_dyn_obj.x_grid,\n             'xo'   : HO_dyn_obj.xo,\n             'po'   : HO_dyn_obj.po,\n             'omega': 1.0,\n             'mass': HO_dyn_obj.mass,\n             'hbar': 1.0}\n</code></pre> <p>And we can now define the state by calling: </p> <pre><code>HO_dyn_obj.custom_grid_state_initialization(custom_gaussian, **func_args)\n</code></pre> <p>Similarly, to define a custom initial state to be used in the Fock/ladder basis, we follow a similar pattern. We first define some custom function that will return a <code>qutip.Qobj</code>: </p> <pre><code>def custom_coherent_state(N_basis):\n    '''\n    Function to define a squeezed coherent state by squeezing, then displacing the vacuum state.\n    '''\n    squeezed_coh_state = qt.displace(N_basis, 2) * qt.squeeze(N_basis, 1.0) * qt.basis(N_basis, 0)\n    return(squeezed_coh_state)\n</code></pre> <p>And define the keyword arguments as a dictionary:</p> <pre><code>qt_func_args = {'N_basis': HO_dyn_obj.n_basis}\n</code></pre> <p>Then we can perform the custom initialization by calling the <code>.custom_ladder_state_initialization()</code> method:</p> <pre><code>HO_dyn_obj.custom_ladder_state_initialization(custom_coherent_state, **qt_func_args)\n</code></pre> <p>For the custom Fock/ladder basis initialization, the custom function must return a <code>qutip.Qobj</code>. </p>"},{"location":"qflux/closed_systems/#defining-the-hamiltonian","title":"Defining the Hamiltonian","text":"<p>The next step for running our dynamics simulation is to define the Hamiltonian, which should describe the system of interest. For the coordinate basis, we assume that the Hamiltonian takes the form of: </p> \\[ H = V(x) + \\frac{p^{2}}{2 m} \\] <p>where \\(V(x)\\) describes the potential energy of our system. <code>qflux</code> provides some example systems out of the box, which we will now demonstrate how to use.</p> <p>To use the built-in potential energy functions, all one must do is use the <code>.set_hamiltonian()</code> method. This method has the optional keyword argument <code>potential_type</code>, which can be used to choose one of the two currently implemented potentials: - Harmonic Oscillator Potential - Arbitrary Quartic Potential</p> <p>The harmonic oscilator potential is implemented in the grid-basis as: </p> \\[ V(x) = \\frac{1}{2} m \\omega^{2} x^{2} \\] <p>and in the ladder basis as: </p> \\[ H = \\hbar \\omega \\left( \\hat{a}^{\\dagger} \\hat{a} + \\frac{1}{2} \\right) \\] <p>The frequency (\\(\\omega\\)) and mass (\\(m\\)) can be controlled when instantiating the dynamics object with the <code>mass</code> and <code>omega</code> keyword arguments. </p> <p>The quartic potential is implemented as: </p> \\[ V(x) = a_{0} + a_{1} \\frac{x}{x_{0}} + a_{2} \\frac{x^{2}}{x_{0}^{2}} + a_{3} \\frac{x^{3}}{x_{0}^{3}} + a_{4} \\frac{x^{4}}{x_{0}^{4}} \\] <p>To use a custom quartic potential, the user should provide a dictionary of keyword arguments that define the coefficients (\\(a_{0}, a_{1}, a_{2}, a_{3}, a_{4}\\)) and the scaling factor \\(x_{0}\\): </p> <pre><code>coeffs_dict = {'a0': 1, 'a1': 1, 'a2': 1, 'a3': 1, 'a4': 1, 'x0': 1}\ndyn_obj.set_hamiltonian(potential_type='quartic', **coeffs_dict)\n</code></pre> <p>For the Fock/ladder basis, the \\(x\\) in the previous equation is replaced with an operator \\(\\hat{a}\\) defined in terms of the creation and annihilation operators as \\(\\hat{x} = \\frac{1}{\\sqrt{2}} \\left( \\hat{a}^{\\dagger} + \\hat{a} \\right)\\) and in the kinetic energy term \\(\\frac{p^{2}}{2m}\\), \\(p\\) is replaced with \\(\\hat{p} =  \\frac{i}{\\sqrt{2}} \\left( \\hat{a}^{dagger} - \\hat{a} \\right)\\).</p> <p><code>qflux</code> also supports arbitrary customization of the potential energy function by use of the <code>.set_H_grid_with_custom_potential()</code> and <code>.set_H_op_with_custom_potential()</code> methods. These methods expect a function and a dictionary (of keyword arguments for that function) as arguments. This is illustrated in the following example: </p> <p>Suppose you have some arbitrary Morse-like potential of the form:</p> \\[ V_{Morse} = De ( 1 - e^{- a (x-x_{eq}))^{2} \\] <p>We can define a python function to to construct this potential:</p> <pre><code>def morse_potential(x_eq=None, mass=None, omega=None, xval=None):\n    De = 8\n    xe = 0\n    k = mass*omega**2\n    a = np.sqrt(k/(2*De))\n    y = De * ((1 - np.exp(-a*(xval-x_eq)))**2)\n    return(y)\n</code></pre> <p>And define a dictionary with parameters to define a specific potential:</p> <pre><code>morse_args = {'x_eq': -1.0, 'mass': 1.0, 'omega': 1.5, 'xval': dyn_obj.x_grid}\n</code></pre> <p>And then construct a Hamiltonian with this custom function for our dynamics object by calling: </p> <pre><code>dyn_obj.set_H_grid_with_custom_potential(morse_potential, **morse_args)\n</code></pre> <p>Similarly, we can do this in a <code>qutip.Qobj</code>-compatible format: </p> <pre><code>def morse_potential_op(x_eq=None, mass=None, omega=None, xval=None):\n    De = 8\n    xe = 0\n    k = mass*omega**2\n    a = np.sqrt(k/(2*De))\n    exponential_f = (-a * (xval - x_eq)).expm()\n    y = De * ((1 - exponential_f)**2)\n    return(y)\n</code></pre> <p>And define our dictionary of custom parameters: </p> <pre><code>morse_op_args = {'x_eq': -1.0, 'mass': 1.0, 'omega': 1.5, 'xval': dyn_obj.x_op}\n</code></pre> <p>And finally we can set our Hamiltonian for the Fock/ladder basis by calling: </p> <pre><code>dyn_obj.set_H_op_with_custom_potential(morse_potential_op, **morse_op_args)\n</code></pre>"},{"location":"qflux/closed_systems/#source-code","title":"Source Code","text":""},{"location":"qflux/closed_systems/#qflux.closed_systems","title":"<code>qflux.closed_systems</code>","text":""},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS","title":"<code>DynamicsCS</code>","text":"<p>Class for closed-system dynamics. All input parameters must be in atomic units to ensure consistency. Please be sure to convert your parameters to atomic units prior to instantiation.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>class DynamicsCS:\n    \"\"\"\n        Class for closed-system dynamics. **All input parameters must be in\n        atomic units to ensure consistency. Please be sure to convert your\n        parameters to atomic units prior to instantiation.**\n\n    \"\"\"\n\n    def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n                 omega: float = 1.0) -&gt; None:\n        \"\"\"\n        Args:\n            n_basis (int): Number of states to include in the chosen representation. If basis\n                = 'ladder', this is the Fock cutoff and defines the number of states\n                used for representing the ladder operators. If basis = 'coordinate',\n                this defines the number of points for the position and momenta.\n\n            xo (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 Bohr.\n\n            po (float, optional): Defines the displacement of the initial state in the position\n                coordinate. Default is 1.0 au.\n\n            mass (float, optional): Defines the mass of the particle/system of interest.\n                Default is 1.0 au.\n\n            omega (float, optional): Frequency of harmonic oscillator.\n                Default is 1.0 au.\n\n        \"\"\"\n        #--------- Required Attributes Populated During Execution ----------#\n        self.n_basis                   = n_basis\n        self.xo                        = xo\n        self.po                        = po\n        self.mass                      = mass\n        self.hbar                      = 1.0\n        self.omega                     = omega\n        #--------- Below are Attributes Populated During Execution ---------#\n        self.total_time                = 0.\n        self.n_tsteps                  = 0.\n        self._KE_op                    = None\n        self._PE_op                    = None\n        self.H_op                      = None\n        self.prop_KE_op                = None\n        self.prop_PE_op                = None\n        self.prop_H_op                 = None\n        # Grid operators\n        self._KE_grid                  = None\n        self._PE_grid                  = None\n        self.H_grid                    = None\n        self.PE_prop_grid              = None\n        self.KE_prop_grid              = None\n\n\n    def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid` and `self.dx` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values between\n        `x_min` and `x_max`.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n\n        Returns:\n            self.dx (float): Spacing between points in the x-coordinate grid.\n            self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n        \"\"\"\n        dx = (x_max - x_min) / self.n_basis\n        x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n        self.dx = dx\n        self.x_grid = x_grid\n        return\n\n\n    def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.p_grid` and `self.dp` attributes. This function\n        generates an array of `self.n_basis` evenly spaced values.\n\n        Args:\n            x_min (float): Minimum value of x-coordinates\n            x_max (float): Maximum value of x-coordinates\n            reorder (bool): Boolean flag to determine whether points should be reordered to be\n                compatible with the FFT routine or not.\n\n        Returns:\n            self.dp (float): Spacing between points in the p-coordinate grid.\n            self.pgrid (array_like): Array of momentum grid points\n        \"\"\"\n        dp = 2 * np.pi / (x_max - x_min)\n        pmin = -dp * self.n_basis / 2\n        pmax = dp * self.n_basis / 2\n        plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n        minus_pgrid = - np.flip(np.copy(plus_pgrid))\n        if reorder:\n            p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n        else:\n            p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n        self.p_grid = p_grid\n        self.dp = dp\n        return\n\n\n    def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n        \"\"\"\n        Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n        attributes. This functions generates an array of `self.n_basis`\n        evenly spaced values.\n\n        Args:\n            x_min : float\n                Minimum value of x-coordinates\n            x_max : float\n                Maximum value of x-coordinates\n            reorder_p : bool\n                Boolean flag to determine whether momentum values should be\n                reordered to be compatible with the FFT routine or not.\n\n        Returns:\n            self.dx : float\n                Spacing between points in the x-coordinate grid.\n            self.xgrid : array_like\n                Array of x-values\n            self.dp : float\n                Spacing between points in the p-coordinate grid.\n            self.pgrid : array_like\n                Array of p-values\n        \"\"\"\n        self._get_xgrid(x_min, x_max)\n        self._get_pgrid(x_min, x_max, reorder=reorder_p)\n        return\n\n\n    def initialize_operators(self):\n        \"\"\"\n            Function to initialize core operators in the chosen basis.\n\n        \"\"\"\n\n        self.a_op = qt.destroy(self.n_basis)\n        self.x_op = qt.position(self.n_basis)\n        self.p_op = qt.momentum(self.n_basis)\n        return\n\n\n    def _set_hamiltonian_grid(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n\n            # Set attributes for the coordinate basis\n            self._PE_grid = self.mass * self.omega ** 2 * self.x_grid ** 2 / 0.5\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_grid / x0\n            self._PE_grid = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n            self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def _set_hamiltonian_qt(self, potential_type: str = 'harmonic', **kwargs):\n        if potential_type == 'harmonic':\n            # Set attributes for the ladder basis\n            self.H_op = self.hbar * self.omega * (self.a_op.dag() * self.a_op + 0.5)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self._PE_op = self.mass * self.omega ** 2 * self.x_op ** 2 / 0.5\n            self.H_xp_op = self._PE_op + self._KE_op\n        elif potential_type == 'quartic':\n            if kwargs:\n                if 'a0' in kwargs:\n                    a0 = kwargs['a0']\n                if 'a1' in kwargs:\n                    a1 = kwargs['a1']\n                if 'a2' in kwargs:\n                    a2 = kwargs['a2']\n                if 'a3' in kwargs:\n                    a3 = kwargs['a3']\n                if 'a4' in kwargs:\n                    a4 = kwargs['a4']\n                if 'x0' in kwargs:\n                    x0 = kwargs['x0']\n                # Assume that all inputs have the proper atomic units:\n                cf = 1.0\n                xi = self.x_op\n\n            else:\n                # Define relevant parameters\n                cf = convert_eV_to_au(1.)\n                x0 = 1.9592\n                a0 = 0.0\n                a1 = 0.429\n                a2 = -1.126\n                a3 = -0.143\n                a4 = 0.563\n                # Do calculation for ladder basis\n                xi = self.x_op / x0\n            self.x0 = x0\n            self._PE_op = cf * (a0 + a1 * xi + a2 * xi ** 2 + a3 * xi ** 3 + a4 * xi ** 4)\n            self._KE_op = self.p_op ** 2 / (2. * self.mass)\n            self.H_op = self._PE_op + self._KE_op\n            return\n\n    def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n        \"\"\"\n        Function to define Hamiltonian.\n\n        Args:\n            potential_type : str\n                String defining the type of potential energy surface.\n                Available options are: ('harmonic', 'quartic', ...)\n\n                Note: You can manually define your potential energy using the functions:\n                    - set_H_grid_with_custom_potential\n                    - set_H_op_with_custom_potential\n\n        \"\"\"\n\n        if potential_type == 'harmonic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        elif potential_type == 'quartic':\n            self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n            self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n        else:\n            print('Error, this potential type has not yet been implemented!')\n            print('Set your parameters with the custom functions!')\n        return\n\n\n    def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the custom potential\n                energy. Must return an array\n\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_grid = potential\n        self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n        self.H_grid = self._PE_grid + self._KE_grid\n        return\n\n\n    def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n        \"\"\"\n        Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n        Args:\n            custom_function (Callable): Function that defines the potential\n                energy in terms of qutip QObj operators. Must return a qutip.Qobj\n        \"\"\"\n        potential = custom_function(**kwargs)\n        self._PE_op = potential\n        self._KE_op = self.p_op ** 2 / (2. * self.mass)\n        self.H_op = self._PE_op + self._KE_op\n        return\n\n\n    def set_initial_state(self, wfn_omega: float = 1.0):\n        \"\"\"\n        Function to define the initial state. By default, a coherent state is\n        used as the initial state defined in the basis chosen upon instantiation\n\n        Args:\n            wfn_omega (float, optional): Defines the frequency/width of the initial state.\n                Default is 1.0 au.\n        \"\"\"\n\n        alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n        psio = qt.coherent(self.n_basis, alpha=alpha_val)\n        # Now populate the initial state in the grid basis\n        normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n        exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                             ((self.x_grid - self.xo) ** 2)\n                             + 1j * self.po * self.x_grid / self.hbar\n                             )\n\n        coherent_state = normalization * exponential\n        # Set the attributes\n        self.psio_grid = coherent_state\n        self.psio_op = psio\n        return\n\n\n\n    def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized grid state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return an array\n        \"\"\"\n\n        self.psio_grid = function_name(**kwargs)\n        return\n\n    def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n        \"\"\"\n        Function to allow for customized ladder state initialization.\n\n        Args:\n            function_name (Callable): name of user-defined function that returns\n                the initial state. Must return a qutip.Qobj.\n        \"\"\"\n\n        self.psio_op = function_name(**kwargs)\n        return\n\n    def set_propagation_time(self, total_time: float, n_tsteps: int):\n        \"\"\"\n        Function to define the propagation time, an array of times from\n        t=0 to total_time, with n_tsteps equally-spaced steps.\n\n        Args:\n        total_time : float\n            The total time for which we wish to compute the dynamics.\n        n_tsteps : int\n            The number of equally-spaced time steps used to compute the dynamics\n\n        Returns:\n        self.tlist : array-like\n\n        \"\"\"\n\n        self.tlist = np.linspace(0., total_time, n_tsteps)\n        self.dt = self.tlist[1] - self.tlist[0]\n        return\n\n\n    def propagate_qt(self, solver_options : dict = None):\n        \"\"\"\n        Function used to propagate with qutip.\n\n        Args:\n            solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n        Returns:\n            dynamics_results (array-like): array containing the propagated state\n\n        \"\"\"\n\n        options = {'nsteps': len(self.tlist),\n                    'progress_bar': True}\n\n        if solver_options:\n            for key in solver_options:\n                options[key] = solver_options[key]\n\n        results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                             options=options)\n\n        self.dynamics_results_op = results\n        return\n\n\n    def propagate_SOFT(self):\n        \"\"\"\n        Function used to propagate with the 2nd-Order Trotter Expansion.\n\n        $$\n        e^{- \\frac{i}{\\\\hbar} H t} \\approx e^{- \\frac{i}{\\\\hbar} V t/2} e^{- \\frac{i}{\\\\hbar} T t} e^{- \\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n        $$\n\n        Returns:\n            dynamics_results_grid (array-like): array containing the propagated state\n                                                shape (n_tsteps x self.n_basis)\n\n        \"\"\"\n        self.tau = self.tlist[1] - self.tlist[0]\n        PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n        KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n        self.PE_prop_grid = PE_prop\n        self.KE_prop_grid = KE_prop\n\n        propagated_states = [self.psio_grid]\n        psi_t = self.psio_grid\n        for ii in range(len(self.tlist)):\n            psi_t_position_grid = PE_prop * psi_t\n            psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n            psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n            propagated_states.append(psi_t)\n\n        self.dynamics_results_grid = np.asarray(propagated_states)[:-1]\n        return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.__init__","title":"<code>__init__(n_basis=128, xo=1.0, po=0.0, mass=1.0, omega=1.0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>n_basis</code> <code>int</code> <p>Number of states to include in the chosen representation. If basis = 'ladder', this is the Fock cutoff and defines the number of states used for representing the ladder operators. If basis = 'coordinate', this defines the number of points for the position and momenta.</p> <code>128</code> <code>xo</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 Bohr.</p> <code>1.0</code> <code>po</code> <code>float</code> <p>Defines the displacement of the initial state in the position coordinate. Default is 1.0 au.</p> <code>0.0</code> <code>mass</code> <code>float</code> <p>Defines the mass of the particle/system of interest. Default is 1.0 au.</p> <code>1.0</code> <code>omega</code> <code>float</code> <p>Frequency of harmonic oscillator. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def __init__(self, n_basis: int = 128, xo: float = 1.0, po: float = 0.0, mass: float = 1.0,\n             omega: float = 1.0) -&gt; None:\n    \"\"\"\n    Args:\n        n_basis (int): Number of states to include in the chosen representation. If basis\n            = 'ladder', this is the Fock cutoff and defines the number of states\n            used for representing the ladder operators. If basis = 'coordinate',\n            this defines the number of points for the position and momenta.\n\n        xo (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 Bohr.\n\n        po (float, optional): Defines the displacement of the initial state in the position\n            coordinate. Default is 1.0 au.\n\n        mass (float, optional): Defines the mass of the particle/system of interest.\n            Default is 1.0 au.\n\n        omega (float, optional): Frequency of harmonic oscillator.\n            Default is 1.0 au.\n\n    \"\"\"\n    #--------- Required Attributes Populated During Execution ----------#\n    self.n_basis                   = n_basis\n    self.xo                        = xo\n    self.po                        = po\n    self.mass                      = mass\n    self.hbar                      = 1.0\n    self.omega                     = omega\n    #--------- Below are Attributes Populated During Execution ---------#\n    self.total_time                = 0.\n    self.n_tsteps                  = 0.\n    self._KE_op                    = None\n    self._PE_op                    = None\n    self.H_op                      = None\n    self.prop_KE_op                = None\n    self.prop_PE_op                = None\n    self.prop_H_op                 = None\n    # Grid operators\n    self._KE_grid                  = None\n    self._PE_grid                  = None\n    self.H_grid                    = None\n    self.PE_prop_grid              = None\n    self.KE_prop_grid              = None\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS._get_pgrid","title":"<code>_get_pgrid(x_min, x_max, reorder=True)</code>","text":"<p>Populate the <code>self.p_grid</code> and <code>self.dp</code> attributes. This function generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum value of x-coordinates</p> required <code>x_max</code> <code>float</code> <p>Maximum value of x-coordinates</p> required <code>reorder</code> <code>bool</code> <p>Boolean flag to determine whether points should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dp (float): Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid (array_like): Array of momentum grid points</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def _get_pgrid(self, x_min: float, x_max: float, reorder: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.p_grid` and `self.dp` attributes. This function\n    generates an array of `self.n_basis` evenly spaced values.\n\n    Args:\n        x_min (float): Minimum value of x-coordinates\n        x_max (float): Maximum value of x-coordinates\n        reorder (bool): Boolean flag to determine whether points should be reordered to be\n            compatible with the FFT routine or not.\n\n    Returns:\n        self.dp (float): Spacing between points in the p-coordinate grid.\n        self.pgrid (array_like): Array of momentum grid points\n    \"\"\"\n    dp = 2 * np.pi / (x_max - x_min)\n    pmin = -dp * self.n_basis / 2\n    pmax = dp * self.n_basis / 2\n    plus_pgrid = np.linspace(0, pmax, self.n_basis // 2 + 1)\n    minus_pgrid = - np.flip(np.copy(plus_pgrid))\n    if reorder:\n        p_grid = np.concatenate((plus_pgrid[:-1], minus_pgrid[:-1]))\n    else:\n        p_grid = np.concatenate((minus_pgrid, plus_pgrid))\n    self.p_grid = p_grid\n    self.dp = dp\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS._get_xgrid","title":"<code>_get_xgrid(x_min, x_max)</code>","text":"<p>Populate the <code>self.x_grid</code> and <code>self.dx</code> attributes. This function generates an array of <code>self.n_basis</code> evenly spaced values between <code>x_min</code> and <code>x_max</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum value of x-coordinates</p> required <code>x_max</code> <code>float</code> <p>Maximum value of x-coordinates</p> required <p>Returns:</p> Type Description <code>None</code> <p>self.dx (float): Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def _get_xgrid(self, x_min: float, x_max: float) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid` and `self.dx` attributes. This function\n    generates an array of `self.n_basis` evenly spaced values between\n    `x_min` and `x_max`.\n\n    Args:\n        x_min (float): Minimum value of x-coordinates\n        x_max (float): Maximum value of x-coordinates\n\n    Returns:\n        self.dx (float): Spacing between points in the x-coordinate grid.\n        self.xgrid (array_like): Array of grid points from x_min to x_max with spacing of dx\n    \"\"\"\n    dx = (x_max - x_min) / self.n_basis\n    x_grid = np.arange(-self.n_basis / 2, self.n_basis / 2) * dx\n    self.dx = dx\n    self.x_grid = x_grid\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.custom_grid_state_initialization","title":"<code>custom_grid_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized grid state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_grid_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized grid state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return an array\n    \"\"\"\n\n    self.psio_grid = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.custom_ladder_state_initialization","title":"<code>custom_ladder_state_initialization(function_name, **kwargs)</code>","text":"<p>Function to allow for customized ladder state initialization.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>Callable</code> <p>name of user-defined function that returns the initial state. Must return a qutip.Qobj.</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def custom_ladder_state_initialization(self, function_name: Callable, **kwargs):\n    \"\"\"\n    Function to allow for customized ladder state initialization.\n\n    Args:\n        function_name (Callable): name of user-defined function that returns\n            the initial state. Must return a qutip.Qobj.\n    \"\"\"\n\n    self.psio_op = function_name(**kwargs)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.initialize_operators","title":"<code>initialize_operators()</code>","text":"<p>Function to initialize core operators in the chosen basis.</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def initialize_operators(self):\n    \"\"\"\n        Function to initialize core operators in the chosen basis.\n\n    \"\"\"\n\n    self.a_op = qt.destroy(self.n_basis)\n    self.x_op = qt.position(self.n_basis)\n    self.p_op = qt.momentum(self.n_basis)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.propagate_SOFT","title":"<code>propagate_SOFT()</code>","text":"<p>Function used to propagate with the 2nd-Order Trotter Expansion.</p> \\[ e^{- \frac{i}{\\hbar} H t} \u0007pprox e^{- \frac{i}{\\hbar} V t/2} e^{- \frac{i}{\\hbar} T t} e^{- \frac{i}{\\hbar} V t/2} + \\mathcal{O}^{3} \\] <p>Returns:</p> Name Type Description <code>dynamics_results_grid</code> <code>array - like</code> <p>array containing the propagated state                                 shape (n_tsteps x self.n_basis)</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_SOFT(self):\n    \"\"\"\n    Function used to propagate with the 2nd-Order Trotter Expansion.\n\n    $$\n    e^{- \\frac{i}{\\\\hbar} H t} \\approx e^{- \\frac{i}{\\\\hbar} V t/2} e^{- \\frac{i}{\\\\hbar} T t} e^{- \\frac{i}{\\\\hbar} V t/2} + \\\\mathcal{O}^{3}\n    $$\n\n    Returns:\n        dynamics_results_grid (array-like): array containing the propagated state\n                                            shape (n_tsteps x self.n_basis)\n\n    \"\"\"\n    self.tau = self.tlist[1] - self.tlist[0]\n    PE_prop = np.exp(-1.0j * self._PE_grid / 2 * self.tau / self.hbar)\n    KE_prop = np.exp(-1.0j * self._KE_grid * self.tau / self.hbar)\n\n    self.PE_prop_grid = PE_prop\n    self.KE_prop_grid = KE_prop\n\n    propagated_states = [self.psio_grid]\n    psi_t = self.psio_grid\n    for ii in range(len(self.tlist)):\n        psi_t_position_grid = PE_prop * psi_t\n        psi_t_momentum_grid = KE_prop * np.fft.fft(psi_t_position_grid, norm=\"ortho\")\n        psi_t = PE_prop * np.fft.ifft(psi_t_momentum_grid, norm=\"ortho\")\n        propagated_states.append(psi_t)\n\n    self.dynamics_results_grid = np.asarray(propagated_states)[:-1]\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.propagate_qt","title":"<code>propagate_qt(solver_options=None)</code>","text":"<p>Function used to propagate with qutip.</p> <p>Parameters:</p> Name Type Description Default <code>solver_options</code> <code>dict</code> <p>A dictionary of arguments to pass to the qutip.sesolve function</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dynamics_results</code> <code>array - like</code> <p>array containing the propagated state</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def propagate_qt(self, solver_options : dict = None):\n    \"\"\"\n    Function used to propagate with qutip.\n\n    Args:\n        solver_options (dict): A dictionary of arguments to pass to the qutip.sesolve function\n\n    Returns:\n        dynamics_results (array-like): array containing the propagated state\n\n    \"\"\"\n\n    options = {'nsteps': len(self.tlist),\n                'progress_bar': True}\n\n    if solver_options:\n        for key in solver_options:\n            options[key] = solver_options[key]\n\n    results = qt.sesolve(self.H_op, self.psio_op, self.tlist,\n                         options=options)\n\n    self.dynamics_results_op = results\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_H_grid_with_custom_potential","title":"<code>set_H_grid_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the custom potential energy. Must return an array</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_grid_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the custom potential\n            energy. Must return an array\n\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_grid = potential\n    self._KE_grid = self.p_grid ** 2 / (2. * self.mass)\n    self.H_grid = self._PE_grid + self._KE_grid\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_H_op_with_custom_potential","title":"<code>set_H_op_with_custom_potential(custom_function, **kwargs)</code>","text":"<p>Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.</p> <p>Parameters:</p> Name Type Description Default <code>custom_function</code> <code>Callable</code> <p>Function that defines the potential energy in terms of qutip QObj operators. Must return a qutip.Qobj</p> required Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_H_op_with_custom_potential(self, custom_function: Callable, **kwargs):\n    \"\"\"\n    Function to allow for user-defined potential defined by custom_function. Must be a function of qutip operators.\n\n    Args:\n        custom_function (Callable): Function that defines the potential\n            energy in terms of qutip QObj operators. Must return a qutip.Qobj\n    \"\"\"\n    potential = custom_function(**kwargs)\n    self._PE_op = potential\n    self._KE_op = self.p_op ** 2 / (2. * self.mass)\n    self.H_op = self._PE_op + self._KE_op\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_coordinate_operators","title":"<code>set_coordinate_operators(x_min=-7.0, x_max=7.0, reorder_p=True)</code>","text":"<p>Populate the <code>self.x_grid</code>, <code>self.p_grid</code>, <code>self.dx</code>, and <code>self.dp</code> attributes. This functions generates an array of <code>self.n_basis</code> evenly spaced values.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <p>float Minimum value of x-coordinates</p> <code>-7.0</code> <code>x_max</code> <p>float Maximum value of x-coordinates</p> <code>7.0</code> <code>reorder_p</code> <p>bool Boolean flag to determine whether momentum values should be reordered to be compatible with the FFT routine or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>self.dx : float Spacing between points in the x-coordinate grid.</p> <code>None</code> <p>self.xgrid : array_like Array of x-values</p> <code>None</code> <p>self.dp : float Spacing between points in the p-coordinate grid.</p> <code>None</code> <p>self.pgrid : array_like Array of p-values</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_coordinate_operators(self, x_min: float = -7., x_max: float = 7., reorder_p: bool = True) -&gt; None:\n    \"\"\"\n    Populate the `self.x_grid`, `self.p_grid`, `self.dx`, and `self.dp`\n    attributes. This functions generates an array of `self.n_basis`\n    evenly spaced values.\n\n    Args:\n        x_min : float\n            Minimum value of x-coordinates\n        x_max : float\n            Maximum value of x-coordinates\n        reorder_p : bool\n            Boolean flag to determine whether momentum values should be\n            reordered to be compatible with the FFT routine or not.\n\n    Returns:\n        self.dx : float\n            Spacing between points in the x-coordinate grid.\n        self.xgrid : array_like\n            Array of x-values\n        self.dp : float\n            Spacing between points in the p-coordinate grid.\n        self.pgrid : array_like\n            Array of p-values\n    \"\"\"\n    self._get_xgrid(x_min, x_max)\n    self._get_pgrid(x_min, x_max, reorder=reorder_p)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_hamiltonian","title":"<code>set_hamiltonian(potential_type='harmonic', **kwargs)</code>","text":"<p>Function to define Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>potential_type</code> <p>str String defining the type of potential energy surface. Available options are: ('harmonic', 'quartic', ...)</p> <p>Note: You can manually define your potential energy using the functions:     - set_H_grid_with_custom_potential     - set_H_op_with_custom_potential</p> <code>'harmonic'</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_hamiltonian(self, potential_type: str = 'harmonic', **kwargs):\n    \"\"\"\n    Function to define Hamiltonian.\n\n    Args:\n        potential_type : str\n            String defining the type of potential energy surface.\n            Available options are: ('harmonic', 'quartic', ...)\n\n            Note: You can manually define your potential energy using the functions:\n                - set_H_grid_with_custom_potential\n                - set_H_op_with_custom_potential\n\n    \"\"\"\n\n    if potential_type == 'harmonic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    elif potential_type == 'quartic':\n        self._set_hamiltonian_grid(potential_type=potential_type, **kwargs)\n        self._set_hamiltonian_qt(potential_type=potential_type, **kwargs)\n    else:\n        print('Error, this potential type has not yet been implemented!')\n        print('Set your parameters with the custom functions!')\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_initial_state","title":"<code>set_initial_state(wfn_omega=1.0)</code>","text":"<p>Function to define the initial state. By default, a coherent state is used as the initial state defined in the basis chosen upon instantiation</p> <p>Parameters:</p> Name Type Description Default <code>wfn_omega</code> <code>float</code> <p>Defines the frequency/width of the initial state. Default is 1.0 au.</p> <code>1.0</code> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_initial_state(self, wfn_omega: float = 1.0):\n    \"\"\"\n    Function to define the initial state. By default, a coherent state is\n    used as the initial state defined in the basis chosen upon instantiation\n\n    Args:\n        wfn_omega (float, optional): Defines the frequency/width of the initial state.\n            Default is 1.0 au.\n    \"\"\"\n\n    alpha_val = (self.xo + 1j * self.po) / np.sqrt(2)\n    psio = qt.coherent(self.n_basis, alpha=alpha_val)\n    # Now populate the initial state in the grid basis\n    normalization = (self.mass * wfn_omega / np.pi / self.hbar) ** (0.25)\n    exponential = np.exp(-1 * (self.mass * wfn_omega / self.hbar / 2) *\n                         ((self.x_grid - self.xo) ** 2)\n                         + 1j * self.po * self.x_grid / self.hbar\n                         )\n\n    coherent_state = normalization * exponential\n    # Set the attributes\n    self.psio_grid = coherent_state\n    self.psio_op = psio\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.DynamicsCS.set_propagation_time","title":"<code>set_propagation_time(total_time, n_tsteps)</code>","text":"<p>Function to define the propagation time, an array of times from t=0 to total_time, with n_tsteps equally-spaced steps.</p> <p>total_time : float     The total time for which we wish to compute the dynamics. n_tsteps : int     The number of equally-spaced time steps used to compute the dynamics</p> <p>Returns: self.tlist : array-like</p> Source code in <code>src/qflux/closed_systems/classical_methods.py</code> <pre><code>def set_propagation_time(self, total_time: float, n_tsteps: int):\n    \"\"\"\n    Function to define the propagation time, an array of times from\n    t=0 to total_time, with n_tsteps equally-spaced steps.\n\n    Args:\n    total_time : float\n        The total time for which we wish to compute the dynamics.\n    n_tsteps : int\n        The number of equally-spaced time steps used to compute the dynamics\n\n    Returns:\n    self.tlist : array-like\n\n    \"\"\"\n\n    self.tlist = np.linspace(0., total_time, n_tsteps)\n    self.dt = self.tlist[1] - self.tlist[0]\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS","title":"<code>QubitDynamicsCS</code>","text":"<p>               Bases: <code>DynamicsCS</code></p> <p>Class to extend <code>DynamicsCS</code> by adding qubit-based methods for dynamics.</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>class QubitDynamicsCS(DynamicsCS):\n    \"\"\"\n    Class to extend `DynamicsCS` by adding qubit-based methods for dynamics.\n\n    \"\"\"\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.n_qubits        = int(np.log2(self.n_basis))\n        self.quantum_circuit = None\n\n\n    def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n        \"\"\"\n        Function to construct the QSOFT Circuit.\n\n        Args:\n            psio (npt.ArrayLike): initial state that we wish to propagate\n        \"\"\"\n        tgrid = self.tlist\n        time_step = self.dt\n        n_qubits = self.n_qubits\n        # Qubit-Basis Propagators\n        self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n        self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n        q_reg = QuantumRegister(n_qubits)\n        c_reg = ClassicalRegister(n_qubits)\n        qc = QuantumCircuit(q_reg)\n        if type(psio) == type(None):\n            qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n        else:\n            qc.initialize(psio, q_reg[:], normalize=True)\n        # Define our PE and KE propagators in Qiskit-friendly manner\n        PE_cirq_op = Operator(self.prop_PE_qubit)\n        KE_cirq_op = Operator(self.prop_KE_qubit)\n        qc.append(PE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n        qc.append(KE_cirq_op, q_reg)\n        qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n        qc.append(PE_cirq_op, q_reg)\n        self.quantum_circuit = qc\n        return(qc)\n\n\n    def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n        \"\"\"\n            Function to replace the now-deprecated Qiskit\n            `QuantumCircuit.execute()` method.\n\n            Args:\n                QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n                backend (qiskit.Backend): qiskit backend instance\n                shots (int): the number of shots to use for circuit sampling\n\n            Returns:\n                job: an executed quantum circuit job\n        \"\"\"\n        if shots:\n            n_shots = shots\n        else:\n            n_shots = 1024 # Use the qiskit default if not specified\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type == sv_type:\n            real_backend = False\n        else:\n            real_backend = True\n\n        if real_backend:\n            QCircuit.measure_all()\n            qc = transpile(QCircuit, backend=backend)\n            sampler = Sampler(backend)\n            job = sampler.run([qc], shots=n_shots)\n        else:\n            # Transpile circuit with statevector backend\n            tmp_circuit = transpile(QCircuit, backend)\n            # Run the transpiled circuit\n            job = backend.run(tmp_circuit, n_shots=shots)\n        return(job)\n\n\n    def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n        \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n        if backend is None:\n            print('A valid backend must be provided ')\n        backend_type = type(backend)\n        sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n        if backend_type != sv_type:\n            self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n            return\n        else:\n\n            psi_in = self.psio_grid\n            # Get initial state from qiskit routine\n            q_reg = QuantumRegister(self.n_qubits)\n            c_reg = ClassicalRegister(self.n_qubits)\n            qc = QuantumCircuit(q_reg, c_reg)\n            qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n            qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n            psio_cirq = qc_result.result().get_statevector().data\n            # Now do propagation loop\n            qubit_dynamics_results = [psio_cirq]\n            for ii in trange(len(self.tlist)):\n                circuit = self._create_QSOFT_Circuit(psio=psi_in)\n                executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n                psi_out = executed_circuit.result().get_statevector().data\n                qubit_dynamics_results.append(psi_out)\n                psi_in = psi_out\n\n            self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n            return\n\n\n    def get_statevector_from_counts(self, counts, n_shots):\n        new_statevector = np.zeros_like(self.psio_grid)\n\n        for key in counts:\n            little_endian_int = int(key, 2)\n            new_statevector[little_endian_int] = counts[key]/n_shots\n        return(new_statevector)\n\n\n    def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n        \"\"\"\n            Function to propagate dynamics object with the qubit SOFT method.\n\n            Args:\n                backend (qiskit.Backend): qiskit backend object\n                n_shots (int): specifies the number of shots to use when\n                    executing the circuit\n\n            Example for using the Statevector Simulator backend:\n                &gt;&gt;&gt; from qiskit_aer import Aer\n                &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n                &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n        \"\"\"\n\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits, name='c')\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        # Now do propagation loop\n        qubit_dynamics_results = []\n        for ii in trange(len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            circuit_result = executed_circuit.result()\n            measured_psi = circuit_result[0].data['meas'].get_counts()\n            self._last_measurement = measured_psi\n            psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n            psi_in = psi_out\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n        return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS._create_QSOFT_Circuit","title":"<code>_create_QSOFT_Circuit(psio=None)</code>","text":"<p>Function to construct the QSOFT Circuit.</p> <p>Parameters:</p> Name Type Description Default <code>psio</code> <code>ArrayLike</code> <p>initial state that we wish to propagate</p> <code>None</code> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _create_QSOFT_Circuit(self, psio: npt.ArrayLike=None):\n    \"\"\"\n    Function to construct the QSOFT Circuit.\n\n    Args:\n        psio (npt.ArrayLike): initial state that we wish to propagate\n    \"\"\"\n    tgrid = self.tlist\n    time_step = self.dt\n    n_qubits = self.n_qubits\n    # Qubit-Basis Propagators\n    self.prop_PE_qubit = np.diag(np.exp(-1j*self._PE_grid/2*time_step))\n    self.prop_KE_qubit = np.diag(np.exp(-1j*self._KE_grid*time_step))\n\n    q_reg = QuantumRegister(n_qubits)\n    c_reg = ClassicalRegister(n_qubits)\n    qc = QuantumCircuit(q_reg)\n    if type(psio) == type(None):\n        qc.initialize(self._psio_grid, q_reg[:], normalize=True)\n    else:\n        qc.initialize(psio, q_reg[:], normalize=True)\n    # Define our PE and KE propagators in Qiskit-friendly manner\n    PE_cirq_op = Operator(self.prop_PE_qubit)\n    KE_cirq_op = Operator(self.prop_KE_qubit)\n    qc.append(PE_cirq_op, q_reg)\n    qc.append(QFT(self.n_qubits, do_swaps=True, inverse=False), q_reg)\n    qc.append(KE_cirq_op, q_reg)\n    qc.append(QFT(self.n_qubits, do_swaps=True, inverse=True), q_reg)\n    qc.append(PE_cirq_op, q_reg)\n    self.quantum_circuit = qc\n    return(qc)\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS._execute_circuit","title":"<code>_execute_circuit(QCircuit, backend=None, shots=None, real_backend=False)</code>","text":"<p>Function to replace the now-deprecated Qiskit <code>QuantumCircuit.execute()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>QCircuit</code> <code>QuantumCircuit</code> <p>qiskit.QuantumCircuit object</p> required <code>backend</code> <code>Backend</code> <p>qiskit backend instance</p> <code>None</code> <code>shots</code> <code>int</code> <p>the number of shots to use for circuit sampling</p> <code>None</code> <p>Returns:</p> Name Type Description <code>job</code> <p>an executed quantum circuit job</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _execute_circuit(self, QCircuit: QuantumCircuit, backend=None, shots: int = None, real_backend: bool = False):\n    \"\"\"\n        Function to replace the now-deprecated Qiskit\n        `QuantumCircuit.execute()` method.\n\n        Args:\n            QCircuit (qiskit.QuantumCircuit): qiskit.QuantumCircuit object\n            backend (qiskit.Backend): qiskit backend instance\n            shots (int): the number of shots to use for circuit sampling\n\n        Returns:\n            job: an executed quantum circuit job\n    \"\"\"\n    if shots:\n        n_shots = shots\n    else:\n        n_shots = 1024 # Use the qiskit default if not specified\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type == sv_type:\n        real_backend = False\n    else:\n        real_backend = True\n\n    if real_backend:\n        QCircuit.measure_all()\n        qc = transpile(QCircuit, backend=backend)\n        sampler = Sampler(backend)\n        job = sampler.run([qc], shots=n_shots)\n    else:\n        # Transpile circuit with statevector backend\n        tmp_circuit = transpile(QCircuit, backend)\n        # Run the transpiled circuit\n        job = backend.run(tmp_circuit, n_shots=shots)\n    return(job)\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS._propagate_qSOFT_real","title":"<code>_propagate_qSOFT_real(backend='statevector_simulator', n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>'statevector_simulator'</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def _propagate_qSOFT_real(self, backend='statevector_simulator', n_shots=1024):\n    \"\"\"\n        Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n\n\n    psi_in = self.psio_grid\n    # Get initial state from qiskit routine\n    q_reg = QuantumRegister(self.n_qubits)\n    c_reg = ClassicalRegister(self.n_qubits, name='c')\n    qc = QuantumCircuit(q_reg, c_reg)\n    qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n    # Now do propagation loop\n    qubit_dynamics_results = []\n    for ii in trange(len(self.tlist)):\n        circuit = self._create_QSOFT_Circuit(psio=psi_in)\n        executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n        circuit_result = executed_circuit.result()\n        measured_psi = circuit_result[0].data['meas'].get_counts()\n        self._last_measurement = measured_psi\n        psi_out = self.get_statevector_from_counts(measured_psi, n_shots)\n        psi_in = psi_out\n        qubit_dynamics_results.append(psi_out)\n        psi_in = psi_out\n\n    self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n    return\n</code></pre>"},{"location":"qflux/closed_systems/#qflux.closed_systems.QubitDynamicsCS.propagate_qSOFT","title":"<code>propagate_qSOFT(backend=None, n_shots=1024)</code>","text":"<p>Function to propagate dynamics object with the qubit SOFT method.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Backend</code> <p>qiskit backend object</p> <code>None</code> <code>n_shots</code> <code>int</code> <p>specifies the number of shots to use when executing the circuit</p> <code>1024</code> Example for using the Statevector Simulator backend <p>from qiskit_aer import Aer backend = Aer.get_backend('statevector_simulator') self.propagate_qSOFT(backend=backend)</p> Source code in <code>src/qflux/closed_systems/qubit_methods.py</code> <pre><code>def propagate_qSOFT(self, backend=None, n_shots: int = 1024):\n    \"\"\"Function to propagate dynamics object with the qubit SOFT method.\n\n        Args:\n            backend (qiskit.Backend): qiskit backend object\n            n_shots (int): specifies the number of shots to use when\n                executing the circuit\n\n        Example for using the Statevector Simulator backend:\n            &gt;&gt;&gt; from qiskit_aer import Aer\n            &gt;&gt;&gt; backend = Aer.get_backend('statevector_simulator')\n            &gt;&gt;&gt; self.propagate_qSOFT(backend=backend)\n    \"\"\"\n    if backend is None:\n        print('A valid backend must be provided ')\n    backend_type = type(backend)\n    sv_type = qiskit_aer.backends.statevector_simulator.StatevectorSimulator\n    if backend_type != sv_type:\n        self._propagate_qSOFT_real(backend=backend, n_shots=n_shots)\n        return\n    else:\n\n        psi_in = self.psio_grid\n        # Get initial state from qiskit routine\n        q_reg = QuantumRegister(self.n_qubits)\n        c_reg = ClassicalRegister(self.n_qubits)\n        qc = QuantumCircuit(q_reg, c_reg)\n        qc.initialize(self.psio_grid, q_reg[:], normalize=True)\n        qc_result = self._execute_circuit(qc, backend=backend, shots=n_shots)\n        psio_cirq = qc_result.result().get_statevector().data\n        # Now do propagation loop\n        qubit_dynamics_results = [psio_cirq]\n        for ii in trange(len(self.tlist)):\n            circuit = self._create_QSOFT_Circuit(psio=psi_in)\n            executed_circuit = self._execute_circuit(circuit, backend=backend, shots=n_shots)\n            psi_out = executed_circuit.result().get_statevector().data\n            qubit_dynamics_results.append(psi_out)\n            psi_in = psi_out\n\n        self.dynamics_results_qubit = np.asarray(qubit_dynamics_results)\n        return\n</code></pre>"},{"location":"qflux/open_systems/","title":"Open Systems Module","text":""},{"location":"qflux/open_systems/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>open_systems</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/open_systems/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/open_systems/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/open_systems/#source-code","title":"Source Code","text":""},{"location":"qflux/open_systems/#qflux.open_systems","title":"<code>qflux.open_systems</code>","text":""},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS","title":"<code>DynamicsOS</code>","text":"<p>Class for open-system dynamics (Lindblad equation).</p> <p>This class provides methods to simulate open-system dynamics described by the Lindblad equation.</p> <p>Attributes:</p> Name Type Description <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system (shape (N, N)).</p> <code>rho0</code> <code>ndarray</code> <p>Initial density matrix (shape (N, N)).</p> <code>c_ops</code> <code>List[ndarray]</code> <p>List of collapse operators (each of shape (N, N)).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DynamicsOS:\n    \"\"\"Class for open-system dynamics (Lindblad equation).\n\n    This class provides methods to simulate open-system dynamics described by the Lindblad equation.\n\n    Attributes:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system (shape (N, N)).\n        rho0 (np.ndarray): Initial density matrix (shape (N, N)).\n        c_ops (List[np.ndarray]): List of collapse operators (each of shape (N, N)).\n    \"\"\"\n\n    def __init__(\n        self,\n        Nsys: int,\n        Hsys: np.ndarray,\n        rho0: np.ndarray,\n        c_ops: Optional[List[np.ndarray]] = None\n    ) -&gt; None:\n        \"\"\"\n        Initialize the DynamicsOS instance.\n\n        Args:\n            Nsys (int): System Hilbert Space Dimension.\n            Hsys (np.ndarray): Hamiltonian of the system.\n            rho0 (np.ndarray): Initial density matrix.\n            c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n        \"\"\"\n        if c_ops is None:\n            c_ops = []\n        self.Nsys: int = Nsys\n        self.Hsys: np.ndarray = Hsys\n        self.rho0: np.ndarray = rho0\n        self.c_ops: List[np.ndarray] = c_ops\n\n    def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n        \"\"\"\n        Compute the propagator of the Lindblad equation using the matrix exponential.\n\n        The propagator is computed by exponentiating the Liouvillian operator defined by the\n        system Hamiltonian and collapse operators.\n\n        Args:\n            time_arr (List[float]): Array of time values for the simulation.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n        Returns:\n            List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n        \"\"\"\n        ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n        # Build the A matrix for time-derivation of the vectorized density matrix.\n        Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n        for i in range(len(self.c_ops)):\n            Amat += 0.5 * (\n                2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n                - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n                - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n            )\n\n        G_prop: List[np.ndarray] = []\n        for i, t in enumerate(time_arr):\n            if Is_show_step:\n                print(\"step\", i, \"time\", t)\n            Gt: np.ndarray = LA.expm(Amat * t)\n            G_prop.append(Gt)\n        return G_prop\n\n    def propagate_matrix_exp(\n        self,\n        time_arr: List[float],\n        observable: np.ndarray,\n        Is_store_state: bool = False,\n        Is_show_step: bool = False,\n        Is_Gt: bool = False,\n    ) -&gt; Any:\n        \"\"\"\n        Solve the Lindblad equation using matrix exponential.\n\n        This method computes the propagator, evolves the initial density matrix, and calculates\n        the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (np.ndarray): Observable matrix for which the expectation value is computed.\n            Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                             Defaults to False.\n            Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n            Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n        Returns:\n            Result: An object with the following attributes:\n                - expect (List[float]): List of expectation values over time.\n                - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n                - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n        \"\"\"\n\n        class Result:\n            \"\"\"Class for storing propagation results.\"\"\"\n            def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n                self.expect: List[float] = []\n                if store_state:\n                    self.density_matrix: List[np.ndarray] = []\n                if include_Gt:\n                    self.Gprop: Optional[List[np.ndarray]] = None\n\n        result = Result(Is_store_state, Is_Gt)\n\n        # Compute the propagator of the Lindblad equation.\n        G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n        if Is_Gt:\n            result.Gprop = G_prop\n\n        # Initialize the vectorized density matrix.\n        vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n        for i, _ in enumerate(time_arr):\n            vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n            # Reshape back to density matrix form.\n            rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n            if Is_store_state:\n                result.density_matrix.append(rhot)\n            result.expect.append(np.trace(rhot @ observable).real)\n\n        return result\n\n    def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n        \"\"\"\n        Propagate the system using QuTiP's `mesolve` function.\n\n        This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n        values of the observable over time.\n\n        Args:\n            time_arr (List[float]): Time array for dynamic simulation.\n            observable (Any): Observable operator(s) for which the expectation value is computed.\n                              Can be a single operator or a list of operators.\n            **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n        Returns:\n            List[float]: List of expectation values of the observable over time.\n        \"\"\"\n        c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n        if isinstance(observable, list):\n            obs = [Qobj(op) for op in observable]\n        else:\n            obs = Qobj(observable)\n\n        result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n        return result.expect\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.Gt_matrix_expo","title":"<code>Gt_matrix_expo(time_arr, Is_show_step=False)</code>","text":"<p>Compute the propagator of the Lindblad equation using the matrix exponential.</p> <p>The propagator is computed by exponentiating the Liouvillian operator defined by the system Hamiltonian and collapse operators.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Array of time values for the simulation.</p> required <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: List of propagators corresponding to each time in <code>time_arr</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def Gt_matrix_expo(self, time_arr: List[float], Is_show_step: bool = False) -&gt; List[np.ndarray]:\n    \"\"\"\n    Compute the propagator of the Lindblad equation using the matrix exponential.\n\n    The propagator is computed by exponentiating the Liouvillian operator defined by the\n    system Hamiltonian and collapse operators.\n\n    Args:\n        time_arr (List[float]): Array of time values for the simulation.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n\n    Returns:\n        List[np.ndarray]: List of propagators corresponding to each time in `time_arr`.\n    \"\"\"\n    ident_h: np.ndarray = np.eye(self.Nsys, dtype=np.complex128)\n\n    # Build the A matrix for time-derivation of the vectorized density matrix.\n    Amat: np.ndarray = -1j * (np.kron(self.Hsys, ident_h) - np.kron(ident_h, self.Hsys.T))\n    for i in range(len(self.c_ops)):\n        Amat += 0.5 * (\n            2.0 * np.kron(self.c_ops[i], self.c_ops[i].conj())\n            - np.kron(ident_h, (self.c_ops[i].T @ self.c_ops[i].conj()))\n            - np.kron((self.c_ops[i].T.conj() @ self.c_ops[i]), ident_h)\n        )\n\n    G_prop: List[np.ndarray] = []\n    for i, t in enumerate(time_arr):\n        if Is_show_step:\n            print(\"step\", i, \"time\", t)\n        Gt: np.ndarray = LA.expm(Amat * t)\n        G_prop.append(Gt)\n    return G_prop\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.__init__","title":"<code>__init__(Nsys, Hsys, rho0, c_ops=None)</code>","text":"<p>Initialize the DynamicsOS instance.</p> <p>Parameters:</p> Name Type Description Default <code>Nsys</code> <code>int</code> <p>System Hilbert Space Dimension.</p> required <code>Hsys</code> <code>ndarray</code> <p>Hamiltonian of the system.</p> required <code>rho0</code> <code>ndarray</code> <p>Initial density matrix.</p> required <code>c_ops</code> <code>Optional[List[ndarray]]</code> <p>List of collapse operators. Defaults to an empty list.</p> <code>None</code> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(\n    self,\n    Nsys: int,\n    Hsys: np.ndarray,\n    rho0: np.ndarray,\n    c_ops: Optional[List[np.ndarray]] = None\n) -&gt; None:\n    \"\"\"\n    Initialize the DynamicsOS instance.\n\n    Args:\n        Nsys (int): System Hilbert Space Dimension.\n        Hsys (np.ndarray): Hamiltonian of the system.\n        rho0 (np.ndarray): Initial density matrix.\n        c_ops (Optional[List[np.ndarray]]): List of collapse operators. Defaults to an empty list.\n    \"\"\"\n    if c_ops is None:\n        c_ops = []\n    self.Nsys: int = Nsys\n    self.Hsys: np.ndarray = Hsys\n    self.rho0: np.ndarray = rho0\n    self.c_ops: List[np.ndarray] = c_ops\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.propagate_matrix_exp","title":"<code>propagate_matrix_exp(time_arr, observable, Is_store_state=False, Is_show_step=False, Is_Gt=False)</code>","text":"<p>Solve the Lindblad equation using matrix exponential.</p> <p>This method computes the propagator, evolves the initial density matrix, and calculates the expectation value of the observable over time. Optionally, it stores the evolved density matrices.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>ndarray</code> <p>Observable matrix for which the expectation value is computed.</p> required <code>Is_store_state</code> <code>bool</code> <p>If True, stores the density matrices at each time step.                              Defaults to False.</p> <code>False</code> <code>Is_show_step</code> <code>bool</code> <p>If True, prints the current simulation step. Defaults to False.</p> <code>False</code> <code>Is_Gt</code> <code>bool</code> <p>If True, includes the propagators in the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Result</code> <code>Any</code> <p>An object with the following attributes: - expect (List[float]): List of expectation values over time. - density_matrix (List[np.ndarray], optional): List of density matrices (if <code>Is_store_state</code> is True). - Gprop (List[np.ndarray], optional): List of propagators (if <code>Is_Gt</code> is True).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_matrix_exp(\n    self,\n    time_arr: List[float],\n    observable: np.ndarray,\n    Is_store_state: bool = False,\n    Is_show_step: bool = False,\n    Is_Gt: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Solve the Lindblad equation using matrix exponential.\n\n    This method computes the propagator, evolves the initial density matrix, and calculates\n    the expectation value of the observable over time. Optionally, it stores the evolved density matrices.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (np.ndarray): Observable matrix for which the expectation value is computed.\n        Is_store_state (bool, optional): If True, stores the density matrices at each time step.\n                                         Defaults to False.\n        Is_show_step (bool, optional): If True, prints the current simulation step. Defaults to False.\n        Is_Gt (bool, optional): If True, includes the propagators in the result. Defaults to False.\n\n    Returns:\n        Result: An object with the following attributes:\n            - expect (List[float]): List of expectation values over time.\n            - density_matrix (List[np.ndarray], optional): List of density matrices (if `Is_store_state` is True).\n            - Gprop (List[np.ndarray], optional): List of propagators (if `Is_Gt` is True).\n    \"\"\"\n\n    class Result:\n        \"\"\"Class for storing propagation results.\"\"\"\n        def __init__(self, store_state: bool, include_Gt: bool) -&gt; None:\n            self.expect: List[float] = []\n            if store_state:\n                self.density_matrix: List[np.ndarray] = []\n            if include_Gt:\n                self.Gprop: Optional[List[np.ndarray]] = None\n\n    result = Result(Is_store_state, Is_Gt)\n\n    # Compute the propagator of the Lindblad equation.\n    G_prop: List[np.ndarray] = self.Gt_matrix_expo(time_arr, Is_show_step)\n    if Is_Gt:\n        result.Gprop = G_prop\n\n    # Initialize the vectorized density matrix.\n    vec_rho0: np.ndarray = self.rho0.reshape(self.Nsys**2)\n\n    for i, _ in enumerate(time_arr):\n        vec_rhot: np.ndarray = G_prop[i] @ vec_rho0\n        # Reshape back to density matrix form.\n        rhot: np.ndarray = vec_rhot.reshape(self.Nsys, self.Nsys)\n\n        if Is_store_state:\n            result.density_matrix.append(rhot)\n        result.expect.append(np.trace(rhot @ observable).real)\n\n    return result\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DynamicsOS.propagate_qt","title":"<code>propagate_qt(time_arr, observable, **kwargs)</code>","text":"<p>Propagate the system using QuTiP's <code>mesolve</code> function.</p> <p>This method solves the Lindblad master equation using QuTiP's <code>mesolve</code> to compute the expectation values of the observable over time.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>Time array for dynamic simulation.</p> required <code>observable</code> <code>Any</code> <p>Observable operator(s) for which the expectation value is computed.               Can be a single operator or a list of operators.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to <code>mesolve</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of expectation values of the observable over time.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def propagate_qt(self, time_arr: List[float], observable: Any, **kwargs: Any) -&gt; List[float]:\n    \"\"\"\n    Propagate the system using QuTiP's `mesolve` function.\n\n    This method solves the Lindblad master equation using QuTiP's `mesolve` to compute the expectation\n    values of the observable over time.\n\n    Args:\n        time_arr (List[float]): Time array for dynamic simulation.\n        observable (Any): Observable operator(s) for which the expectation value is computed.\n                          Can be a single operator or a list of operators.\n        **kwargs: Additional keyword arguments to pass to `mesolve`.\n\n    Returns:\n        List[float]: List of expectation values of the observable over time.\n    \"\"\"\n    c_ops: List[Qobj] = [Qobj(c_op) for c_op in self.c_ops]\n\n    if isinstance(observable, list):\n        obs = [Qobj(op) for op in observable]\n    else:\n        obs = Qobj(observable)\n\n    result = mesolve(Qobj(self.Hsys), Qobj(self.rho0), time_arr, c_ops, obs, **kwargs)\n    return result.expect\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS","title":"<code>QubitDynamicsOS</code>","text":"<p>               Bases: <code>DynamicsOS</code></p> <p>Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.</p> <p>This class provides methods to initialize state vectors, construct quantum circuits, and perform quantum simulations using Qiskit backends.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>class QubitDynamicsOS(DynamicsOS):\n    \"\"\"\n    Class for simulating quantum dynamics using either vectorized density matrix or Kraus operator representations.\n\n    This class provides methods to initialize state vectors, construct quantum circuits,\n    and perform quantum simulations using Qiskit backends.\n    \"\"\"\n\n    def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize a QubitDynamicsOS instance.\n\n        Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n        Additional keyword arguments are passed to the base DynamicsOS class.\n\n        Args:\n            rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n            **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if rep == 'Density':\n            # Vectorized density matrix representation\n            self.rep: str = 'Density'\n            self.Nqb: int = int(np.log2(self.Nsys**2))\n        elif rep == 'Kraus':\n            # Kraus operator representation\n            self.rep = 'Kraus'\n            self.Nqb = int(np.log2(self.Nsys))\n\n        # The counting qubits bit string and observable matrix are initialized to None.\n        self.count_str: Optional[List[str]] = None\n        self.observable: Optional[np.ndarray] = None\n\n        # Default dilation method for quantum simulation.\n        self.dilation_method: str = 'Sz-Nagy'\n\n    def set_dilation_method(self, method: str) -&gt; None:\n        \"\"\"\n        Set the dilation method for quantum simulation.\n\n        Args:\n            method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n        \"\"\"\n        self.dilation_method = method\n\n    def set_count_str(self, count_str: List[str]) -&gt; None:\n        \"\"\"\n        Set the counting bit string for measurement.\n\n        Args:\n            count_str (List[str]): The counting bit string.\n        \"\"\"\n        self.count_str = count_str\n\n    def set_observable(self, observable: np.ndarray) -&gt; None:\n        \"\"\"\n        Set the observable for the quantum simulation.\n\n        Args:\n            observable (np.ndarray): The observable matrix.\n        \"\"\"\n        self.observable = observable\n\n    def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n        \"\"\"\n        Initialize the state vector from the initial density operator using vectorized representation.\n\n        The initial density matrix is reshaped into a vector and normalized.\n\n        Returns:\n            Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n            of the original vectorized density matrix.\n        \"\"\"\n        vec_rho0 = self.rho0.reshape(self.Nsys**2)\n        norm0 = LA.norm(vec_rho0, 2)\n        statevec = vec_rho0 / norm0\n        return statevec, norm0\n\n    def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n        \"\"\"\n        Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n        The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n        below the specified tolerance are ignored.\n\n        Args:\n            tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n        Returns:\n            Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n            corresponding probabilities.\n        \"\"\"\n        eigenvalues, eigenvectors = LA.eigh(self.rho0)\n        statevec: List[np.ndarray] = []\n        prob: List[float] = []\n        for i in range(len(eigenvalues) - 1, -1, -1):\n            if abs(eigenvalues[i]) &lt; tol:\n                break\n            prob.append(eigenvalues[i])\n            statevec.append(eigenvectors[:, i])\n        return statevec, prob\n\n    def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n        \"\"\"\n        Prepare and return the Qiskit observable operator.\n\n        Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n        Args:\n            Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n                Defaults to False.\n            tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n        Returns:\n            SparsePauliOp: The Qiskit representation of the observable.\n        \"\"\"\n        if self.observable is None:\n            print('Error: observable is None')\n\n        if Isdilate:\n            num_qubits = self.Nqb + 1\n            Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n            Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n        else:\n            num_qubits = self.Nqb\n            Obs_mat = self.observable\n\n        Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n        # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n        data: List[str] = []\n        coef: List[float] = []\n        for key in Obs_paulis_dic:\n            data.append(key)\n            coef.append(Obs_paulis_dic[key])\n        obs_q = SparsePauliOp(data, coef)\n        return obs_q\n\n    def qc_simulation_kraus(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n        Gprop: Optional[List[np.ndarray]] = None,\n        tolk: float = 1e-5,\n        tolo: float = 1e-5,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the Kraus operator representation.\n\n        This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n        It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n        and accumulates the measurement results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of shots for each measurement. Defaults to 1024.\n            Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n                If None, Kraus operators are generated from the propagator. Defaults to None.\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n            tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            np.ndarray: Array containing the quantum simulation results.\n        \"\"\"\n        nsteps = len(time_arr)\n\n        # Generate Kraus operators if not provided.\n        if Kraus is None:\n            Kraus = {}\n            if Gprop is None:\n                print('Calculating the propagator')\n                Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n            print('Generating the Kraus operators')\n            for i in range(nsteps):\n                print('At step', i, 'of', nsteps)\n                Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n        print('Kraus operator generation complete')\n\n        # Perform Qiskit simulation using the Estimator.\n        estimator = Estimator()\n\n        statevec, prob = self.init_statevec_Kraus()\n        n_inistate = len(statevec)\n        print('Number of initial states in the density matrix:', n_inistate)\n        print('Probabilities:', prob)\n\n        # Obtain the Qiskit observable.\n        obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n        print('Starting quantum simulation')\n        result_simulation = np.zeros(nsteps, dtype=np.float64)\n\n        for i in range(nsteps):\n            print('Simulation step', i, 'of', nsteps)\n            current_kraus_list = Kraus[i]\n            print('Number of Kraus operators:', len(current_kraus_list))\n            for kraus_op in current_kraus_list:\n                for istate in range(n_inistate):\n                    qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                    result = estimator.run(qc, obs_q, shots=shots).result()\n                    result_simulation[i] += result.values[0] * prob[istate]\n\n        return result_simulation\n\n    def qc_simulation_vecdens(\n        self,\n        time_arr: List[float],\n        shots: int = 1024,\n        backend: Any = AerSimulator(),\n        Gprop: Optional[List[np.ndarray]] = None,\n        **kwargs: Any\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Perform quantum simulation using the vectorized density matrix representation.\n\n        This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n        based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n        Args:\n            time_arr (List[float]): List of time steps for simulation.\n            shots (int, optional): Number of measurement shots. Defaults to 1024.\n            backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n            Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n                If None, it will be calculated. Defaults to None.\n            **kwargs: Additional keyword arguments for propagator calculation.\n\n        Returns:\n            np.ndarray: Array containing the quantum simulation results.\n        \"\"\"\n        if Gprop is None:\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n        nsteps = len(time_arr)\n\n        if self.count_str is None:\n            print(\"Error: count_str is not assigned\")\n\n        n_bitstr = len(self.count_str)\n        statevec, norm0 = self.init_statevec_vecdens()\n        result = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n\n        for i in range(nsteps):\n            if i % 100 == 0:\n                print('Quantum simulation step', i)\n            Gt = Gprop[i]\n            circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n            circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n            if self.dilation_method == 'SVD-Walsh':\n                circuit = transpile(circuit, backend)\n            counts = backend.run(circuit, shots=shots).result().get_counts()\n            for j in range(n_bitstr):\n                bitstr = self.count_str[j]\n                if bitstr in counts:\n                    result[i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n                else:\n                    print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n        return result\n\n    def _create_circuit(\n        self,\n        array: np.ndarray,\n        statevec: Union[np.ndarray, List[np.ndarray]],\n        Isscale: bool = True\n    ) -&gt; QuantumCircuit:\n        \"\"\"\n        Construct and return the quantum circuit.\n\n        This method wraps the call to the dilation circuit construction function.\n\n        Args:\n            array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n            statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n            Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n        Returns:\n            QuantumCircuit: The constructed quantum circuit.\n        \"\"\"\n        return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.__init__","title":"<code>__init__(rep='Density', **kwargs)</code>","text":"<p>Initialize a QubitDynamicsOS instance.</p> <p>Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed. Additional keyword arguments are passed to the base DynamicsOS class.</p> <p>Parameters:</p> Name Type Description Default <code>rep</code> <code>str</code> <p>Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.</p> <code>'Density'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the DynamicsOS initializer.</p> <code>{}</code> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def __init__(self, rep: str = 'Density', **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize a QubitDynamicsOS instance.\n\n    Depending on the representation, either \"Density\" or \"Kraus\", the number of qubits is computed.\n    Additional keyword arguments are passed to the base DynamicsOS class.\n\n    Args:\n        rep (str, optional): Representation type, either 'Density' or 'Kraus'. Defaults to 'Density'.\n        **kwargs: Additional keyword arguments for the DynamicsOS initializer.\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if rep == 'Density':\n        # Vectorized density matrix representation\n        self.rep: str = 'Density'\n        self.Nqb: int = int(np.log2(self.Nsys**2))\n    elif rep == 'Kraus':\n        # Kraus operator representation\n        self.rep = 'Kraus'\n        self.Nqb = int(np.log2(self.Nsys))\n\n    # The counting qubits bit string and observable matrix are initialized to None.\n    self.count_str: Optional[List[str]] = None\n    self.observable: Optional[np.ndarray] = None\n\n    # Default dilation method for quantum simulation.\n    self.dilation_method: str = 'Sz-Nagy'\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS._create_circuit","title":"<code>_create_circuit(array, statevec, Isscale=True)</code>","text":"<p>Construct and return the quantum circuit.</p> <p>This method wraps the call to the dilation circuit construction function.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Array used for circuit construction (e.g., propagator or Kraus operator).</p> required <code>statevec</code> <code>Union[ndarray, List[ndarray]]</code> <p>State vector(s) to be used in the circuit.</p> required <code>Isscale</code> <code>bool</code> <p>Flag indicating whether scaling should be applied. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QuantumCircuit</code> <code>QuantumCircuit</code> <p>The constructed quantum circuit.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def _create_circuit(\n    self,\n    array: np.ndarray,\n    statevec: Union[np.ndarray, List[np.ndarray]],\n    Isscale: bool = True\n) -&gt; QuantumCircuit:\n    \"\"\"\n    Construct and return the quantum circuit.\n\n    This method wraps the call to the dilation circuit construction function.\n\n    Args:\n        array (np.ndarray): Array used for circuit construction (e.g., propagator or Kraus operator).\n        statevec (Union[np.ndarray, List[np.ndarray]]): State vector(s) to be used in the circuit.\n        Isscale (bool, optional): Flag indicating whether scaling should be applied. Defaults to True.\n\n    Returns:\n        QuantumCircuit: The constructed quantum circuit.\n    \"\"\"\n    return dc.construct_circuit(self.Nqb, array, statevec, method=self.dilation_method, Isscale=Isscale)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS._get_qiskit_observable","title":"<code>_get_qiskit_observable(Isdilate=False, tol=0.005)</code>","text":"<p>Prepare and return the Qiskit observable operator.</p> <p>Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.</p> <p>Parameters:</p> Name Type Description Default <code>Isdilate</code> <code>bool</code> <p>Flag indicating whether to use the dilated observable. Defaults to False.</p> <code>False</code> <code>tol</code> <code>float</code> <p>Tolerance for the Pauli decomposition. Defaults to 5e-3.</p> <code>0.005</code> <p>Returns:</p> Name Type Description <code>SparsePauliOp</code> <code>SparsePauliOp</code> <p>The Qiskit representation of the observable.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def _get_qiskit_observable(self, Isdilate: bool = False, tol: float = 5e-3) -&gt; SparsePauliOp:\n    \"\"\"\n    Prepare and return the Qiskit observable operator.\n\n    Converts the observable matrix to its Pauli representation and returns a SparsePauliOp.\n\n    Args:\n        Isdilate (bool, optional): Flag indicating whether to use the dilated observable.\n            Defaults to False.\n        tol (float, optional): Tolerance for the Pauli decomposition. Defaults to 5e-3.\n\n    Returns:\n        SparsePauliOp: The Qiskit representation of the observable.\n    \"\"\"\n    if self.observable is None:\n        print('Error: observable is None')\n\n    if Isdilate:\n        num_qubits = self.Nqb + 1\n        Obs_mat = np.zeros((2 * self.Nsys, 2 * self.Nsys), dtype=np.complex128)\n        Obs_mat[:self.Nsys, :self.Nsys] = self.observable[:self.Nsys, :self.Nsys]\n    else:\n        num_qubits = self.Nqb\n        Obs_mat = self.observable\n\n    Obs_paulis_dic = tb.ham_to_pauli(Obs_mat, num_qubits, tol=tol)\n\n    # Prepare the Qiskit observable from the Pauli strings of the observable matrix.\n    data: List[str] = []\n    coef: List[float] = []\n    for key in Obs_paulis_dic:\n        data.append(key)\n        coef.append(Obs_paulis_dic[key])\n    obs_q = SparsePauliOp(data, coef)\n    return obs_q\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.init_statevec_Kraus","title":"<code>init_statevec_Kraus(tol=1e-06)</code>","text":"<p>Initialize state vectors from the initial density operator using the Kraus operator representation.</p> <p>The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues below the specified tolerance are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of</p> <code>List[float]</code> <p>corresponding probabilities.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_Kraus(self, tol: float = 1e-6) -&gt; Tuple[List[np.ndarray], List[float]]:\n    \"\"\"\n    Initialize state vectors from the initial density operator using the Kraus operator representation.\n\n    The density matrix is decomposed using eigenvalue decomposition, and eigenstates with eigenvalues\n    below the specified tolerance are ignored.\n\n    Args:\n        tol (float, optional): Tolerance for ignoring eigenstates with small eigenvalues. Defaults to 1e-6.\n\n    Returns:\n        Tuple[List[np.ndarray], List[float]]: A tuple containing a list of state vectors and a list of\n        corresponding probabilities.\n    \"\"\"\n    eigenvalues, eigenvectors = LA.eigh(self.rho0)\n    statevec: List[np.ndarray] = []\n    prob: List[float] = []\n    for i in range(len(eigenvalues) - 1, -1, -1):\n        if abs(eigenvalues[i]) &lt; tol:\n            break\n        prob.append(eigenvalues[i])\n        statevec.append(eigenvectors[:, i])\n    return statevec, prob\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.init_statevec_vecdens","title":"<code>init_statevec_vecdens()</code>","text":"<p>Initialize the state vector from the initial density operator using vectorized representation.</p> <p>The initial density matrix is reshaped into a vector and normalized.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm</p> <code>float</code> <p>of the original vectorized density matrix.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def init_statevec_vecdens(self) -&gt; Tuple[np.ndarray, float]:\n    \"\"\"\n    Initialize the state vector from the initial density operator using vectorized representation.\n\n    The initial density matrix is reshaped into a vector and normalized.\n\n    Returns:\n        Tuple[np.ndarray, float]: A tuple containing the normalized state vector and the norm\n        of the original vectorized density matrix.\n    \"\"\"\n    vec_rho0 = self.rho0.reshape(self.Nsys**2)\n    norm0 = LA.norm(vec_rho0, 2)\n    statevec = vec_rho0 / norm0\n    return statevec, norm0\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.qc_simulation_kraus","title":"<code>qc_simulation_kraus(time_arr, shots=1024, Kraus=None, Gprop=None, tolk=1e-05, tolo=1e-05, **kwargs)</code>","text":"<p>Perform quantum simulation using the Kraus operator representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach. It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator, and accumulates the measurement results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of shots for each measurement. Defaults to 1024.</p> <code>1024</code> <code>Kraus</code> <code>Optional[Dict[int, List[ndarray]]]</code> <p>Dictionary mapping time step index to a list of Kraus operators. If None, Kraus operators are generated from the propagator. Defaults to None.</p> <code>None</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>tolk</code> <code>float</code> <p>Tolerance for generating Kraus operators. Defaults to 1e-5.</p> <code>1e-05</code> <code>tolo</code> <code>float</code> <p>Tolerance for observable decomposition. Defaults to 1e-5.</p> <code>1e-05</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing the quantum simulation results.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_kraus(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    Kraus: Optional[Dict[int, List[np.ndarray]]] = None,\n    Gprop: Optional[List[np.ndarray]] = None,\n    tolk: float = 1e-5,\n    tolo: float = 1e-5,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the Kraus operator representation.\n\n    This method simulates the quantum system dynamics over a series of time steps using a Kraus operator-based approach.\n    It constructs quantum circuits for each Kraus operator and initial state, runs the simulation using Qiskit's Estimator,\n    and accumulates the measurement results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of shots for each measurement. Defaults to 1024.\n        Kraus (Optional[Dict[int, List[np.ndarray]]], optional): Dictionary mapping time step index to a list of Kraus operators.\n            If None, Kraus operators are generated from the propagator. Defaults to None.\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        tolk (float, optional): Tolerance for generating Kraus operators. Defaults to 1e-5.\n        tolo (float, optional): Tolerance for observable decomposition. Defaults to 1e-5.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        np.ndarray: Array containing the quantum simulation results.\n    \"\"\"\n    nsteps = len(time_arr)\n\n    # Generate Kraus operators if not provided.\n    if Kraus is None:\n        Kraus = {}\n        if Gprop is None:\n            print('Calculating the propagator')\n            Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n        print('Generating the Kraus operators')\n        for i in range(nsteps):\n            print('At step', i, 'of', nsteps)\n            Kraus[i] = gen_Kraus_list(Gprop[i], self.Nsys, tol=tolk)\n    print('Kraus operator generation complete')\n\n    # Perform Qiskit simulation using the Estimator.\n    estimator = Estimator()\n\n    statevec, prob = self.init_statevec_Kraus()\n    n_inistate = len(statevec)\n    print('Number of initial states in the density matrix:', n_inistate)\n    print('Probabilities:', prob)\n\n    # Obtain the Qiskit observable.\n    obs_q = self._get_qiskit_observable(Isdilate=True, tol=tolo)\n\n    print('Starting quantum simulation')\n    result_simulation = np.zeros(nsteps, dtype=np.float64)\n\n    for i in range(nsteps):\n        print('Simulation step', i, 'of', nsteps)\n        current_kraus_list = Kraus[i]\n        print('Number of Kraus operators:', len(current_kraus_list))\n        for kraus_op in current_kraus_list:\n            for istate in range(n_inistate):\n                qc = self._create_circuit(kraus_op, statevec[istate], Isscale=False)\n                result = estimator.run(qc, obs_q, shots=shots).result()\n                result_simulation[i] += result.values[0] * prob[istate]\n\n    return result_simulation\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.qc_simulation_vecdens","title":"<code>qc_simulation_vecdens(time_arr, shots=1024, backend=AerSimulator(), Gprop=None, **kwargs)</code>","text":"<p>Perform quantum simulation using the vectorized density matrix representation.</p> <p>This method simulates the quantum system dynamics over a series of time steps by constructing circuits based on the vectorized density matrix representation, performing measurements, and processing the results.</p> <p>Parameters:</p> Name Type Description Default <code>time_arr</code> <code>List[float]</code> <p>List of time steps for simulation.</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots. Defaults to 1024.</p> <code>1024</code> <code>backend</code> <code>Any</code> <p>Quantum simulation backend. Defaults to AerSimulator().</p> <code>AerSimulator()</code> <code>Gprop</code> <code>Optional[List[ndarray]]</code> <p>Propagator matrix (or list of matrices) for simulation. If None, it will be calculated. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for propagator calculation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array containing the quantum simulation results.</p> Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def qc_simulation_vecdens(\n    self,\n    time_arr: List[float],\n    shots: int = 1024,\n    backend: Any = AerSimulator(),\n    Gprop: Optional[List[np.ndarray]] = None,\n    **kwargs: Any\n) -&gt; np.ndarray:\n    \"\"\"\n    Perform quantum simulation using the vectorized density matrix representation.\n\n    This method simulates the quantum system dynamics over a series of time steps by constructing circuits\n    based on the vectorized density matrix representation, performing measurements, and processing the results.\n\n    Args:\n        time_arr (List[float]): List of time steps for simulation.\n        shots (int, optional): Number of measurement shots. Defaults to 1024.\n        backend (Any, optional): Quantum simulation backend. Defaults to AerSimulator().\n        Gprop (Optional[List[np.ndarray]], optional): Propagator matrix (or list of matrices) for simulation.\n            If None, it will be calculated. Defaults to None.\n        **kwargs: Additional keyword arguments for propagator calculation.\n\n    Returns:\n        np.ndarray: Array containing the quantum simulation results.\n    \"\"\"\n    if Gprop is None:\n        Gprop = self.Gt_matrix_expo(time_arr, **kwargs)\n\n    nsteps = len(time_arr)\n\n    if self.count_str is None:\n        print(\"Error: count_str is not assigned\")\n\n    n_bitstr = len(self.count_str)\n    statevec, norm0 = self.init_statevec_vecdens()\n    result = np.zeros((nsteps, n_bitstr), dtype=np.float64)\n\n    for i in range(nsteps):\n        if i % 100 == 0:\n            print('Quantum simulation step', i)\n        Gt = Gprop[i]\n        circuit, norm = self._create_circuit(Gt, statevec, Isscale=True)\n        circuit.measure(range(self.Nqb + 1), range(self.Nqb + 1))\n        if self.dilation_method == 'SVD-Walsh':\n            circuit = transpile(circuit, backend)\n        counts = backend.run(circuit, shots=shots).result().get_counts()\n        for j in range(n_bitstr):\n            bitstr = self.count_str[j]\n            if bitstr in counts:\n                result[i, j] = np.sqrt(counts[bitstr] / shots) * norm * norm0\n            else:\n                print('At time', i, 'with shots =', shots, \"no counts for\", bitstr)\n\n    return result\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.set_count_str","title":"<code>set_count_str(count_str)</code>","text":"<p>Set the counting bit string for measurement.</p> <p>Parameters:</p> Name Type Description Default <code>count_str</code> <code>List[str]</code> <p>The counting bit string.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_count_str(self, count_str: List[str]) -&gt; None:\n    \"\"\"\n    Set the counting bit string for measurement.\n\n    Args:\n        count_str (List[str]): The counting bit string.\n    \"\"\"\n    self.count_str = count_str\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.set_dilation_method","title":"<code>set_dilation_method(method)</code>","text":"<p>Set the dilation method for quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_dilation_method(self, method: str) -&gt; None:\n    \"\"\"\n    Set the dilation method for quantum simulation.\n\n    Args:\n        method (str): The dilation method, e.g., 'Sz-Nagy', 'SVD', or 'SVD-Walsh'.\n    \"\"\"\n    self.dilation_method = method\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.QubitDynamicsOS.set_observable","title":"<code>set_observable(observable)</code>","text":"<p>Set the observable for the quantum simulation.</p> <p>Parameters:</p> Name Type Description Default <code>observable</code> <code>ndarray</code> <p>The observable matrix.</p> required Source code in <code>src/qflux/open_systems/quantum_simulation.py</code> <pre><code>def set_observable(self, observable: np.ndarray) -&gt; None:\n    \"\"\"\n    Set the observable for the quantum simulation.\n\n    Args:\n        observable (np.ndarray): The observable matrix.\n    \"\"\"\n    self.observable = observable\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid","title":"<code>DVR_grid</code>","text":"<p>Class for Discrete Variable Representation (DVR) grid methods.</p> <p>This class handles grid-based representations for systems where the potential is expressed on grid points.</p> <p>Attributes:</p> Name Type Description <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> <code>xmin</code> <code>float</code> <p>Minimum value of the grid.</p> <code>xmax</code> <code>float</code> <p>Maximum value of the grid.</p> <code>mass</code> <code>float</code> <p>Mass of the particle.</p> <code>xgrid</code> <code>ndarray</code> <p>Array of grid points in position space.</p> <code>dx</code> <code>float</code> <p>Spacing between grid points.</p> <code>dk</code> <code>float</code> <p>Spacing in momentum space.</p> <code>kgrid</code> <code>ndarray</code> <p>Array of grid points in momentum space.</p> <code>ak2</code> <code>ndarray</code> <p>Kinetic energy array in momentum space.</p> <code>hamk</code> <code>ndarray</code> <p>Kinetic Hamiltonian matrix in position space.</p> <code>potential</code> <code>Optional[ndarray]</code> <p>Potential energy array on the grid.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>class DVR_grid:\n    \"\"\"Class for Discrete Variable Representation (DVR) grid methods.\n\n    This class handles grid-based representations for systems where the potential is expressed on grid points.\n\n    Attributes:\n        Ngrid (int): Number of grid points.\n        xmin (float): Minimum value of the grid.\n        xmax (float): Maximum value of the grid.\n        mass (float): Mass of the particle.\n        xgrid (np.ndarray): Array of grid points in position space.\n        dx (float): Spacing between grid points.\n        dk (float): Spacing in momentum space.\n        kgrid (np.ndarray): Array of grid points in momentum space.\n        ak2 (np.ndarray): Kinetic energy array in momentum space.\n        hamk (np.ndarray): Kinetic Hamiltonian matrix in position space.\n        potential (Optional[np.ndarray]): Potential energy array on the grid.\n    \"\"\"\n\n    def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n        \"\"\"\n        Initialize the DVR_grid instance.\n\n        Args:\n            xmin (float): Minimum x-value.\n            xmax (float): Maximum x-value.\n            Ngrid (int): Number of grid points.\n            mass (float): Mass of the particle.\n        \"\"\"\n        self.Ngrid: int = Ngrid\n        self.xmin: float = xmin\n        self.xmax: float = xmax\n        self.mass: float = mass\n\n        # Set up the position grid.\n        self.xgrid: np.ndarray = np.array([])\n        self._set_xgrid()\n        self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n        # Set up the momentum grid.\n        self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n        self.kgrid: np.ndarray = np.array([])\n        self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n        self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n        self._set_kinet_ham()\n\n        # Potential energy array (to be set later).\n        self.potential: Optional[np.ndarray] = None\n\n    def _set_xgrid(self) -&gt; None:\n        \"\"\"\n        Set up the position space grid.\n\n        Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n        \"\"\"\n        self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n\n    def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n        \"\"\"\n        Set up the potential energy array on the grid.\n\n        Args:\n            func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n        \"\"\"\n        self.potential = np.zeros_like(self.xgrid)\n        for i in range(self.Ngrid):\n            self.potential[i] = func_pot(self.xgrid[i])\n\n    def _set_kinet_ham(self) -&gt; None:\n        \"\"\"\n        Set up the kinetic Hamiltonian matrix in position space.\n\n        This method computes the momentum grid and the corresponding kinetic energy values,\n        and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n        \"\"\"\n        self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n        self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n        coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n        for i in range(self.Ngrid):\n            if i &lt; self.Ngrid // 2:\n                self.kgrid[i] = i * self.dk\n            else:\n                self.kgrid[i] = -(self.Ngrid - i) * self.dk\n            self.ak2[i] = coef_k * self.kgrid[i]**2\n\n        akx0: np.ndarray = sfft.ifft(self.ak2)\n        self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n        for i in range(self.Ngrid):\n            for j in range(self.Ngrid):\n                if i &lt; j:\n                    self.hamk[i, j] = akx0[i - j].conj()\n                else:\n                    self.hamk[i, j] = akx0[i - j]\n\n    def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Get the eigenstates for the potential in x-space.\n\n        Args:\n            Nstate (int): Number of eigenstates to output.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: A tuple containing:\n                - Eigenvalues (np.ndarray) for the first `Nstate` states.\n                - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n        \"\"\"\n        Mata: np.ndarray = self.hamk.copy()\n        for i in range(self.Ngrid):\n            Mata[i, i] += self.potential[i]\n\n        val, arr = LA.eigh(Mata)\n        return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n\n    def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from position space to momentum space.\n\n        Args:\n            psi (np.ndarray): Wavefunction in position space.\n\n        Returns:\n            np.ndarray: Wavefunction in momentum space.\n        \"\"\"\n        return tb.x2k_wave(self.dx, psi)\n\n    def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform the wavefunction from momentum space to position space.\n\n        Args:\n            psik (np.ndarray): Wavefunction in momentum space.\n\n        Returns:\n            np.ndarray: Wavefunction in position space.\n        \"\"\"\n        return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.__init__","title":"<code>__init__(xmin, xmax, Ngrid, mass)</code>","text":"<p>Initialize the DVR_grid instance.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>Minimum x-value.</p> required <code>xmax</code> <code>float</code> <p>Maximum x-value.</p> required <code>Ngrid</code> <code>int</code> <p>Number of grid points.</p> required <code>mass</code> <code>float</code> <p>Mass of the particle.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def __init__(self, xmin: float, xmax: float, Ngrid: int, mass: float) -&gt; None:\n    \"\"\"\n    Initialize the DVR_grid instance.\n\n    Args:\n        xmin (float): Minimum x-value.\n        xmax (float): Maximum x-value.\n        Ngrid (int): Number of grid points.\n        mass (float): Mass of the particle.\n    \"\"\"\n    self.Ngrid: int = Ngrid\n    self.xmin: float = xmin\n    self.xmax: float = xmax\n    self.mass: float = mass\n\n    # Set up the position grid.\n    self.xgrid: np.ndarray = np.array([])\n    self._set_xgrid()\n    self.dx: float = self.xgrid[1] - self.xgrid[0]\n\n    # Set up the momentum grid.\n    self.dk: float = 2.0 * np.pi / (self.Ngrid * self.dx)\n    self.kgrid: np.ndarray = np.array([])\n    self.ak2: np.ndarray = np.array([])  # Kinetic energy array.\n    self.hamk: np.ndarray = np.array([])  # Kinetic Hamiltonian matrix.\n    self._set_kinet_ham()\n\n    # Potential energy array (to be set later).\n    self.potential: Optional[np.ndarray] = None\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid._set_kinet_ham","title":"<code>_set_kinet_ham()</code>","text":"<p>Set up the kinetic Hamiltonian matrix in position space.</p> <p>This method computes the momentum grid and the corresponding kinetic energy values, and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def _set_kinet_ham(self) -&gt; None:\n    \"\"\"\n    Set up the kinetic Hamiltonian matrix in position space.\n\n    This method computes the momentum grid and the corresponding kinetic energy values,\n    and constructs the kinetic Hamiltonian matrix in position space using a Fourier transform.\n    \"\"\"\n    self.kgrid = np.zeros(self.Ngrid, dtype=np.float64)\n    self.ak2 = np.zeros(self.Ngrid, dtype=np.float64)\n\n    coef_k: float = pa.hbar**2 / (2.0 * self.mass)\n\n    for i in range(self.Ngrid):\n        if i &lt; self.Ngrid // 2:\n            self.kgrid[i] = i * self.dk\n        else:\n            self.kgrid[i] = -(self.Ngrid - i) * self.dk\n        self.ak2[i] = coef_k * self.kgrid[i]**2\n\n    akx0: np.ndarray = sfft.ifft(self.ak2)\n    self.hamk = np.zeros((self.Ngrid, self.Ngrid), dtype=np.complex128)\n\n    for i in range(self.Ngrid):\n        for j in range(self.Ngrid):\n            if i &lt; j:\n                self.hamk[i, j] = akx0[i - j].conj()\n            else:\n                self.hamk[i, j] = akx0[i - j]\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid._set_xgrid","title":"<code>_set_xgrid()</code>","text":"<p>Set up the position space grid.</p> <p>Initializes the <code>xgrid</code> attribute using a linear space between <code>xmin</code> and <code>xmax</code>.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def _set_xgrid(self) -&gt; None:\n    \"\"\"\n    Set up the position space grid.\n\n    Initializes the `xgrid` attribute using a linear space between `xmin` and `xmax`.\n    \"\"\"\n    self.xgrid = np.linspace(self.xmin, self.xmax, self.Ngrid)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.get_eig_state","title":"<code>get_eig_state(Nstate)</code>","text":"<p>Get the eigenstates for the potential in x-space.</p> <p>Parameters:</p> Name Type Description Default <code>Nstate</code> <code>int</code> <p>Number of eigenstates to output.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing: - Eigenvalues (np.ndarray) for the first <code>Nstate</code> states. - Eigenvectors (np.ndarray) for the first <code>Nstate</code> states, normalized by sqrt(dx).</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def get_eig_state(self, Nstate: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Get the eigenstates for the potential in x-space.\n\n    Args:\n        Nstate (int): Number of eigenstates to output.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - Eigenvalues (np.ndarray) for the first `Nstate` states.\n            - Eigenvectors (np.ndarray) for the first `Nstate` states, normalized by sqrt(dx).\n    \"\"\"\n    Mata: np.ndarray = self.hamk.copy()\n    for i in range(self.Ngrid):\n        Mata[i, i] += self.potential[i]\n\n    val, arr = LA.eigh(Mata)\n    return val[:Nstate], arr[:, :Nstate] / np.sqrt(self.dx)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.k2x_wave","title":"<code>k2x_wave(psik)</code>","text":"<p>Transform the wavefunction from momentum space to position space.</p> <p>Parameters:</p> Name Type Description Default <code>psik</code> <code>ndarray</code> <p>Wavefunction in momentum space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in position space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def k2x_wave(self, psik: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from momentum space to position space.\n\n    Args:\n        psik (np.ndarray): Wavefunction in momentum space.\n\n    Returns:\n        np.ndarray: Wavefunction in position space.\n    \"\"\"\n    return tb.k2x_wave(self.dx, psik)\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.set_potential","title":"<code>set_potential(func_pot)</code>","text":"<p>Set up the potential energy array on the grid.</p> <p>Parameters:</p> Name Type Description Default <code>func_pot</code> <code>Callable[[float], float]</code> <p>Function that returns the potential value at a given x.</p> required Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def set_potential(self, func_pot: Callable[[float], float]) -&gt; None:\n    \"\"\"\n    Set up the potential energy array on the grid.\n\n    Args:\n        func_pot (Callable[[float], float]): Function that returns the potential value at a given x.\n    \"\"\"\n    self.potential = np.zeros_like(self.xgrid)\n    for i in range(self.Ngrid):\n        self.potential[i] = func_pot(self.xgrid[i])\n</code></pre>"},{"location":"qflux/open_systems/#qflux.open_systems.DVR_grid.x2k_wave","title":"<code>x2k_wave(psi)</code>","text":"<p>Transform the wavefunction from position space to momentum space.</p> <p>Parameters:</p> Name Type Description Default <code>psi</code> <code>ndarray</code> <p>Wavefunction in position space.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wavefunction in momentum space.</p> Source code in <code>src/qflux/open_systems/numerical_methods.py</code> <pre><code>def x2k_wave(self, psi: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform the wavefunction from position space to momentum space.\n\n    Args:\n        psi (np.ndarray): Wavefunction in position space.\n\n    Returns:\n        np.ndarray: Wavefunction in momentum space.\n    \"\"\"\n    return tb.x2k_wave(self.dx, psi)\n</code></pre>"},{"location":"qflux/variational_methods/","title":"Variational Methods  Module","text":""},{"location":"qflux/variational_methods/#overview","title":"Overview","text":"<p>In this section, we outline the main functionality of the <code>variational_methods</code> module. </p> <p>First, we will provide some conceptual explanations that provide the user with a necessary background to understand the code. Then we provide some illustrative examples that demonstrate how the code can be used. Finally, we provide the source code as an API reference to the source code.</p>"},{"location":"qflux/variational_methods/#concepts","title":"Concepts","text":"<p>In this section, we can add some theoretical background/explanation of relevant concepts.</p>"},{"location":"qflux/variational_methods/#examples","title":"Examples","text":"<p>In this section, we can add some illustrative examples. </p>"},{"location":"qflux/variational_methods/#source-code","title":"Source Code","text":""},{"location":"qflux/variational_methods/#qflux.variational_methods","title":"<code>qflux.variational_methods</code>","text":""},{"location":"qflux/workflows/","title":"GitHub Workflows","text":"<p>This project uses several GitHub Actions workflows to automate various development and release processes. Here's a detailed overview of each workflow:</p>"},{"location":"qflux/workflows/#code-quality-qualityyml","title":"Code Quality (<code>quality.yml</code>)","text":"<p>This workflow ensures code quality standards are maintained:</p> <ul> <li>Trigger: Runs on every push and pull request</li> <li>Actions:</li> <li>Runs Ruff for linting and formatting checks</li> <li>Runs MyPy for static type checking</li> <li>Environment: Uses Python 3.12 and uv for dependency management</li> </ul>"},{"location":"qflux/workflows/#tests-testsyml","title":"Tests (<code>tests.yml</code>)","text":"<p>Handles automated testing of the codebase:</p> <ul> <li>Trigger: Runs on every push and pull request</li> <li>Actions:</li> <li>Sets up Python 3.12 environment</li> <li>Installs project dependencies using uv</li> <li>Runs pytest with verbose output</li> <li>Features:</li> <li>Caches dependencies for faster workflow execution</li> <li>Uses virtual environment for isolated testing</li> </ul>"},{"location":"qflux/workflows/#release-management","title":"Release Management","text":""},{"location":"qflux/workflows/#release-drafter-release-drafteryml","title":"Release Drafter (<code>release-drafter.yml</code>)","text":"<p>Automates the creation of release notes and manages PR labeling:</p> <ul> <li>Triggers:</li> <li>On push to main branch</li> <li>On pull request events (opened, reopened, synchronize)</li> <li>Manual trigger (workflow_dispatch)</li> <li>Actions:</li> <li>Automatically assigns labels to PRs based on commit message prefixes</li> <li>Drafts release notes based on PR labels</li> <li>Commit Prefix to Label Mapping:</li> <li><code>BREAKING CHANGE</code>, <code>BREAKING</code>, <code>MAJOR</code> \u2192 breaking-change</li> <li><code>feat</code>, <code>FEAT</code>, <code>Feature</code> \u2192 new-feature</li> <li><code>fix</code>, <code>FIX</code>, <code>Fixed</code> \u2192 bugfix</li> <li><code>enhance</code>, <code>ENHANCE</code>, <code>improvement</code> \u2192 enhancement</li> <li><code>refactor</code>, <code>REFACTOR</code> \u2192 refactor</li> <li><code>perf</code>, <code>PERFORMANCE</code> \u2192 performance</li> <li><code>docs</code>, <code>DOC</code> \u2192 documentation</li> <li><code>tests</code>, <code>TESTS</code> \u2192 tests</li> <li>Categories:</li> <li>\ud83d\udea8 Breaking changes</li> <li>\u2728 New features</li> <li>\ud83d\udc1b Bug fixes</li> <li>\ud83d\ude80 Enhancements</li> <li>\ud83e\uddf0 Maintenance</li> <li>\ud83d\udcda Documentation</li> <li>\u2b06\ufe0f Dependency updates</li> <li>Version Resolution:</li> <li>Major: breaking changes</li> <li>Minor: new features, enhancements</li> <li>Patch: bugfixes, default updates</li> </ul>"},{"location":"qflux/workflows/#publish-release-publish-releaseyml","title":"Publish Release (<code>publish-release.yml</code>)","text":"<p>Handles the publication of releases:</p> <ul> <li>Trigger: Runs when a release is published</li> <li>Actions:</li> <li>Builds Python package using uv</li> <li>Uploads built artifacts to the GitHub release</li> <li>Environment: Uses Python 3.12 and uv for building</li> </ul>"},{"location":"qflux/workflows/#version-management","title":"Version Management","text":""},{"location":"qflux/workflows/#version-bump-version-bumpyml","title":"Version Bump (<code>version-bump.yml</code>)","text":"<p>Handles automated version bumping of the project.</p>"},{"location":"qflux/workflows/#update-majorminor-tags-update-major-minor-tagsyml","title":"Update Major/Minor Tags (<code>update-major-minor-tags.yml</code>)","text":"<p>Updates major and minor version tags when new releases are published.</p>"},{"location":"qflux/workflows/#workflow-dependencies","title":"Workflow Dependencies","text":"<p>All workflows use:</p> <ul> <li><code>uv</code> for Python package management</li> <li>GitHub Actions cache for optimizing workflow execution</li> <li>Ubuntu latest as the running environment</li> </ul>"},{"location":"qflux/workflows/#best-practices","title":"Best Practices","text":"<p>When contributing to this project:</p> <ol> <li>Ensure your commits are properly labeled to be categorized in release notes</li> <li>All tests must pass and code quality checks must succeed</li> <li>New features should include appropriate tests</li> <li>Breaking changes must be clearly marked with the \"breaking-change\" label</li> </ol>"}]}